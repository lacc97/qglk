<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./t3dict_files/filelist.xml">
<title>Parsing Player Commands</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Merkin Muffley</o:Author>
  <o:LastAuthor>Dell User</o:LastAuthor>
  <o:Revision>24</o:Revision>
  <o:TotalTime>97</o:TotalTime>
  <o:Created>2000-02-25T23:58:00Z</o:Created>
  <o:LastSaved>2002-09-07T21:00:00Z</o:LastSaved>
  <o:Pages>4</o:Pages>
  <o:Words>2618</o:Words>
  <o:Characters>14923</o:Characters>
  <o:Lines>124</o:Lines>
  <o:Paragraphs>29</o:Paragraphs>
  <o:CharactersWithSpaces>18326</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>125</w:Zoom>
  <w:DrawingGridHorizontalSpacing>6 pt</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>6 pt</w:DrawingGridVerticalSpacing>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:AutoSpaceLikeWord95/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:0pt;
	font-weight:normal;
	font-style:italic;}
h2
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:13.0pt;
	font-family:Arial;}
h4
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:4;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-style:italic;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	background:navy;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
tt
	{mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:466704818;
	mso-list-type:hybrid;
	mso-list-template-ids:-1642795046 67698691 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:o;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<h3 style='tab-stops:.5in'>Dictionaries</h3>

<p class=MsoNormal>To facilitate command parsing, TADS 3 provides an intrinsic
class called &quot;Dictionary.&quot;<span style="mso-spacerun: yes">  </span>A
Dictionary object stores associations between &quot;keys&quot; and objects, and
can be efficiently searched for a key to yield all of the objects associated
with the key.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>A &quot;key&quot; is a combination of a string and a
property ID.<span style="mso-spacerun: yes">  </span>The Dictionary class
includes a property ID with each key so that object associations can be
differentiated by type; each property is a type of association.<span
style="mso-spacerun: yes">  </span>In practical terms, the property used in a
dictionary key will usually be a vocabulary property, such as &quot;noun&quot;
or &quot;adjective.&quot;<span style="mso-spacerun: yes">   </span>A given word
might be used with some objects as a noun, but with other objects as an
adjective; for example, &quot;card&quot; might be used as a noun with an
&quot;ID Card&quot; object, but as an adjective with a &quot;card slot&quot;
object.<span style="mso-spacerun: yes">  </span>The Dictionary class
differentiates by property ID to allow for searching a Dictionary object for
the objects matching a word in a particular usage context.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>You must define the Dictionary intrinsic class to use
Dictionary objects in your program.<span style="mso-spacerun: yes">  </span>The
easiest way to do this is to include the system header file &lt;dict.h&gt;,
which is included with the compiler.</p>

<h3><a name=dictionaryStatement></a>Comparators</h3>

<p class=MsoNormal>The Dictionary class allows the program to customize the way
input strings are matched to dictionary strings.<span style="mso-spacerun:
yes">  </span>This customization is handled through a &quot;comparator&quot;
object; this is simply an object that provides a specific set of methods, which
the Dictionary calls to perform its comparisons.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>You can set a Dictionary object's comparator at any time by
calling the Dictionary's setComparator() method.<span style="mso-spacerun:
yes">  </span>This method takes the comparator object as an argument.<span
style="mso-spacerun: yes">  </span>When you set the comparator, subsequent
look-up operations are performed using the matching rules contained in the new
comparator.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The intrinsic class <a href="t3strcmp.htm">StringComparator</a>
provides a customizable comparator implementation, compatible with the
Dictionary requirements, that is very fast (since it's implemented as native
code in the interpreter).<span style="mso-spacerun: yes">  </span>When the
StringComparator class doesn't provide enough flexibility, you can define your
own comparator by implementing the set of required methods.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The Dictionary class assumes that comparator objects are immutable.<span
style="mso-spacerun: yes">  </span>That is, once a comparator is installed in a
dictionary, the dictionary assumes that the return values from the required
methods, for a given set of argument values, will never change.<span
style="mso-spacerun: yes">  </span>This is important because it allows the
dictionary to assume it will never need to rebuild its internal tables except
when a new comparator is installed.<span style="mso-spacerun: yes">  </span>If
you want to change the comparison rules, you <b>must</b> create and install a
new comparator object; never attempt to change the comparison rules by modifying
the comparator itself.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>A comparator object must define the following methods:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><b>calcHash(<i>str</i>) – </b>calculate and return the
&quot;hash code&quot; for the given string.<span style="mso-spacerun: yes"> 
</span>The hash code is simply an arbitrary integer value; its purpose is to
allow the dictionary to divide its overall set of words into many bins, which
reduces the amount of work necessary when searching for a particular string by
limiting the search to the strings in one bin.<span style="mso-spacerun: yes"> 
</span>When storing a string, the dictionary computes the hash value by calling
this method, then stores the string in a bin specified by the hash value.<span
style="mso-spacerun: yes">  </span>When looking up a string, the dictionary
computes the string's hash value, and then only has to look in the bin given by
the hash value.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Note that this function doesn't have to worry about how many
bins the dictionary is using.<span style="mso-spacerun: yes">  </span>The
dictionary will automatically take the value modulo the bin count (i.e., the
dictionary will divide the value returned from calcHash() by the number of
bins, and use the integer remainder of this division to select the bin; this
will inherently be in the correct range).</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The hash value returned from this method is arbitrary, hence
the method can implement any algorithm it wants for computing the value.<span
style="mso-spacerun: yes">  </span>However, there is one absolute requirement
that the method must obey, and a couple of properties that the algorithm should
have:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=circle>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>The
     absolute requirement is that, for <b>any</b> two strings <i>s1</i> and <i>s2</i>,
     if matchValues(<i>s1</i>, <i>s2</i>) indicates a match (i.e., it returns
     anything other than zero or nil), then calcHash(<i>s1</i>) must equal
     calcHash(<i>s2</i>).<span style="mso-spacerun: yes">  </span>(This does <i>not</i>
     imply that the hash values for two non-matching strings must be different:
     hash &quot;collisions,&quot; in which two strings do not match but happen
     to have the same hash value, are specifically allowed.)</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>A
     highly desirable property of the hash function is that it runs
     quickly.<span style="mso-spacerun: yes">  </span>The point of the hash is
     to reduce the amount of work needed to look up a word by very quickly
     picking only one bin to look in.<span style="mso-spacerun: yes"> 
     </span>If the hash function takes a long time to compute, then the speed
     advantage of this approach is reduced.</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>Another
     highly desirable property is that the hash values for the set of all words
     in the dictionary should distribute uniformly.<span style="mso-spacerun:
     yes">  </span>This is important because it will ensure that about an equal
     number of words goes into each bin, so that we don't have many empty bins
     and a few bins with all of the words; if the words were to clump into a
     few bins, then we wouldn't get much advantage out of limiting the
     searching to one bin per word looked up.<span style="mso-spacerun: yes"> 
     </span>There's no sure way to guarantee uniform hash distribution,
     especially given that the set of words in a particular dictionary can't be
     predicted in most cases; however, practice has shown that certain types of
     hash functions generally work pretty well.<span style="mso-spacerun:
     yes">  </span>If you are writing your own comparator object, you can find
     information on how to write a good hash function in practically any
     textbook on computer algorithms.</li>
</ul>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><b>matchValues(<i>inputStr, dictStr</i>) – </b>match the
input string <i>inputStr</i> to the dictionary string <i>dictStr</i>.<span
style="mso-spacerun: yes">  </span>Returns zero or nil if the values do not
match, or any other value if they do match.<span style="mso-spacerun: yes"> 
</span>Because any non-zero and non-nil value indicates a match, this routine
is free to encode additional information about the match in the return value;
typically, implementations use bit flags (a combination of binary values OR'd
together) for this purpose.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Note the asymmetry of the argument: the first argument is
always an input string, which is a string to be matched (such as the string
argument to the findWord() method); the second is always a dictionary string,
which is a string already stored in the dictionary that is being compared with
the input word.<span style="mso-spacerun: yes">  </span>Some implementations
might take advantage of this distinction to permit certain types of
approximations in input strings; for example, an implementation might allow an
input string to be abbreviated to a leading substring of the dictionary string,
so that &quot;flashl&quot; matches &quot;flashlight,&quot; but not vice versa.</p>

<h3>Compiler Support</h3>

<p class=MsoNormal>The TADS 3 compiler has built-in support for the Dictionary
intrinsic class.<span style="mso-spacerun: yes">  </span>(This built-in support
is part of the compiler, not the interpreter; as far as the interpreter is
concerned, a Dictionary object is the same as any other kind of object.)<span
style="mso-spacerun: yes">  </span>The compiler support is provided by two new
statements, <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>dictionary</span></tt> and <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>dictionary property</span></tt>,
and by recognition of dictionary properties when defined in object property
lists.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>dictionary</span></tt> statement has two purposes.<span
style="mso-spacerun: yes">  </span>First, it defines a new object instance of
class Dictionary, if the name has not been previously defined.<span
style="mso-spacerun: yes">  </span>Second, it establishes the <i>active
dictionary</i>, which is the dictionary into which the compiler will insert
each dictionary word defined with an object.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>dictionary property</span></tt> statement tells the compiler
that a given property is henceforth a dictionary property.<span
style="mso-spacerun: yes">  </span>This means that, whenever the property is
subsequently used in an object definition, the property defines dictionary
words for the object.<span style="mso-spacerun: yes">  </span>The words are
entered into the active dictionary under the given property.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Here's some sample code that demonstrates how these
statements work.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>// create a new dictionary and make it active</pre><pre>dictionary myDict;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre>// establish the dictionary properties</pre><pre>dictionary property noun, adjective, plural;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre>// define an object</pre><pre>redBook: Book</pre><pre><span style="mso-spacerun: yes">    </span>noun = 'book' 'booklet'</pre><pre><span style="mso-spacerun: yes">    </span>adjective = 'red'</pre><pre>;</pre>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The effect of these new statements makes the code needed to
define an object with vocabulary words very similar to the way it looked in
TADS 2.<span style="mso-spacerun: yes">  </span>In particular, note that
dictionary properties accept the special implied list syntax that TADS 2 used
for vocabulary words: there is no need to enclose a vocabulary property's
string list in square brackets.<span style="mso-spacerun: yes">  </span>In
fact, the TADS 3 compiler doesn't even allow list notation for dictionary
properties.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Even though the code looks similar to the way it did in TADS
2, though, there are some important differences.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>First, the <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>noun</span></tt> and <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>adjective</span></tt>
properties at run-time behave like normal properties: the compiler sets the
values of these properties to simple string lists containing the strings
actually defined, <i>plus </i>any strings inherited from superclasses.<span
style="mso-spacerun: yes">  </span>You can use and modify these properties
during program execution just like any other; however, note that, because these
properties are nothing special to the interpreter, changing them has no effect
on the dictionary.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Second, the dictionary object created by the <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>dictionary</span></tt>
statement is a full-fledged object at run-time.<span style="mso-spacerun:
yes">  </span>This means that you can call Dictionary methods on this object in
your program, to look up words and modify the dictionary dynamically.</p>

<h3>Dictionary Methods</h3>

<p class=MsoNormal>The object is an instance of the intrinsic class Dictionary,
which provides the following methods:</p>

<pre><span style='font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre>

<p class=MsoNormal style='tab-stops:.5in'><b>addWord(<i>obj</i>,<i> str</i>,
&amp;<i>voc_prop</i>)</b> – add an object to the dictionary with the given
string and property key.<span style="mso-spacerun: yes">  </span>The argument <b><i>str</i></b>
can be a string value, or can be a list of strings; if <b><i>str</i></b> is a
list of strings, the result is the same as calling <b>addWord()</b> for each string
in the list.<span style="mso-spacerun: yes">  </span>If the word association to
be added is already defined (i.e., another entry with the same string, object,
and property already exists), the new association is simply ignored.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>findWord(<i>str</i>, &amp;<i>voc_prop</i>?)</b>
– search the dictionary for the given string and property ID.<span
style="mso-spacerun: yes">  </span>Returns a list giving all of the matching
objects; if there are no objects, returns an empty list.<span
style="mso-spacerun: yes">  </span>If <i>voc_prop</i> is omitted or is nil, the
method returns all of the objects that match the string for <i>any</i>
property.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'>The returned list consists of <i>two</i>
elements for each matching object.<span style="mso-spacerun: yes">  </span>The
first element of each pair is the matching object; the second element is the
return value from the current comparator's matchValues() method for the match.<span
style="mso-spacerun: yes">  </span>For example, suppose that the comparator
simply returns nil for no match or true for a match; the result list might then
look like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>[blueBook, true, booklet, true, matchbook, true]</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The matchValues() result is included
because some comparators use the result to supply additional information about
the match.<span style="mso-spacerun: yes">  </span>For example, <a
href="t3strcmp.htm">StringComparator</a> encodes information on case folding,
truncation, and equivalence mappings.<span style="mso-spacerun: yes"> 
</span>The caller could use this information to choose some matches over
others, for example.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>isWordDefined(<i>str</i>) </b>–
searches the dictionary for the given string and determines if it's associated
with any objects.<span style="mso-spacerun: yes">  </span>If the word occurs in
the dictionary at all, this function returns true; otherwise, it returns nil.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>forEachWord(<i>func</i>) – </b>invokes
the callback function <i>func</i> on each word association in the
dictionary.<span style="mso-spacerun: yes">  </span>The callback is invoked as <i>func</i>(<i>obj,
str, voc_prop</i>), where <i>obj, str,</i> and <i>voc_prop</i> have the same
meanings they do in addWord().<span style="mso-spacerun: yes">  </span>Note
that a given string can appear many times in a dictionary, so <i>func</i> can
be invoked with the same <i>str</i> value multiple times, once for each
string/object/property association.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>removeWord(<i>obj</i>,<i> str</i>,
&amp;<i>voc_prop</i>)</b> – removes from the dictionary the object's
association with the given string and property key.<span style="mso-spacerun:
yes">  </span>Only the specific association of object, string, and property is
removed; if the same object is also associated with other strings, the object
is not removed from those other associations, and likewise if the same string
and property are associated with different objects, those object associations
are not removed.<span style="mso-spacerun: yes">  </span><b><i>str</i></b> can
be a string value or a list of strings; if it's a list of strings, the result
is the same as calling <b>removeWord()</b> for each string in the list.<span
style="mso-spacerun: yes">  </span>If the word association to be removed is not
defined, the operation is simply ignored.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>setComparator(<i>compObj</i>) – </b>set
the comparator object.<span style="mso-spacerun: yes">  </span>All subsequent
dictionary operations are performed with the new comparator object.<span
style="mso-spacerun: yes">  </span>If <i>compObj</i> is nil, the dictionary
simply matches input strings to dictionary strings exactly.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Once installed, the dictionary
considers a comparator object to be immutable.<span style="mso-spacerun: yes"> 
</span>That is, the dictionary assumes that the return values from the required
methods of the comparator for a given set of inputs will never change.<span
style="mso-spacerun: yes">  </span>If you want to change the comparison rules
for a dictionary, you <b>must</b> create and install a new comparator object:
never attempt to change the comparison rules by modifying an existing
comparator.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note that changing the comparator is
a relatively expensive operation, because the dictionary must rebuild its
internal table for the new comparator; programs should thus avoid changing comparators
except when necessary.</p>

<h3>Notes</h3>

<p class=MsoNormal style='tab-stops:.5in'>There are a few other important
things to know about dictionaries.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>Dictionaries and garbage
collection:</b><span style="mso-spacerun: yes">  </span>A dictionary references
its objects &quot;weakly.&quot;<span style="mso-spacerun: yes">  </span>This
means that adding an object to a dictionary does <i>not</i> prevent the garbage
collector from deleting the object.<span style="mso-spacerun: yes">  </span>If
an object is referenced in a dictionary, but the object becomes otherwise
unreachable, the garbage collector will delete the object, and will at the same
time remove all of the object's associations from the dictionary.<span
style="mso-spacerun: yes">  </span>While this might seem strange at first glance,
it is actually very useful, because it means that you don't have to worry about
manually deleting dictionary references to objects that have become unneeded.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Because dictionaries reference their
entries weakly, the mere presence of an object in a dictionary never keeps the
garbage collector from deleting the object.<span style="mso-spacerun: yes"> 
</span>Hence, if an object in a dictionary becomes otherwise unreachable, the
collector will eventually delete the object.<span style="mso-spacerun: yes"> 
</span>This is normally desirable, because dictionaries are usually used only
as a performance optimization to make it quicker to find an object given its
name.<span style="mso-spacerun: yes">  </span>However, it is sometimes the case
that a dictionary is the primary way to access a group of objects; in these
cases, the weak references that a dictionary uses are undesirable because they
don't prevent your objects from being deleted.<span style="mso-spacerun: yes"> 
</span>In these cases, you must create some other explicit reference to your
objects; an easy way to accomplish this is to add each such object to a list stored
in a property of a static object.<span style="mso-spacerun: yes">  </span>You
must take care to remove these explicit references when their objects are no
longer needed, so that the objects can be deleted.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>Creating dictionaries dynamically:</b><span
style="mso-spacerun: yes">  </span>You can create a dictionary object at
run-time using the <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>new</span></tt> operator.<span style="mso-spacerun: yes"> 
</span>Note that, in order to do this, you must define the Dictionary intrinsic
class to the compiler, which you would normally accomplish simply by including
the dictionary system header file.</p>

<pre><span style='font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre><pre>// include the system header defining the Dictionary class</pre><pre>#include &lt;dict.h&gt;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre>myFunc()</pre><pre>{</pre><pre><span style="mso-spacerun: yes">    </span>// create a new dictionary with truncation length 9</pre><pre><span style="mso-spacerun: yes">    </span>local dict = new Dictionary(9);</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">    </span>// add some words</pre><pre><span style="mso-spacerun: yes">    </span>dict.addWord(redBook, 'red', &amp;adjective);</pre><pre><span style="mso-spacerun: yes">    </span>dict.addWord(redBook, 'book', &amp;noun);</pre><pre>}</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>Using multiple dictionaries in the
compiler:</b> <span style="mso-spacerun: yes"> </span>You can use multiple
dictionaries at compile-time simply by using a new <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>dictionary</span></tt>
statement for each dictionary.<span style="mso-spacerun: yes">  </span>You can
switch back to an existing dictionary with another <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>dictionary</span></tt>
statement naming the original dictionary.<span style="mso-spacerun: yes"> 
</span>The <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>dictionary</span></tt> statement establishes the active
dictionary, which remains in effect until the next <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>dictionary</span></tt>
statement.<span style="mso-spacerun: yes">  </span>Multiple dictionaries might
be useful in certain situations, such as when you want to create different
parsing modes, each having their own separate vocabulary words.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>Dynamic object creation and
dictionaries:</b><span style="mso-spacerun: yes">  </span>When you create a new
object with operator <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>new</span></tt>, the interpreter will <i>not </i>automatically
add any vocabulary to any dictionary for the object.<span style="mso-spacerun:
yes">  </span>While this might seem a deficiency, remember that the interpreter
doesn't think of dictionary objects as anything special, so it doesn't have any
idea that you might want some random object creation to have a side effect on a
completely unrelated object (such as a dictionary).<span style="mso-spacerun:
yes">  </span>However, in most cases you will probably not notice this lack of
automatic action, because libraries should be able to handle this more or less
transparently through inheritance.<span style="mso-spacerun: yes">  </span>In
particular, most libraries will probably want to put something like this in
their lowest level classes:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>class Thing: object</pre><pre><span style="mso-spacerun: yes">    </span>construct()</pre><pre><span style="mso-spacerun: yes">    </span>{</pre><pre><span style="mso-spacerun: yes">        </span>// add all of my vocabulary to the default dictionary</pre><pre><span style="mso-spacerun: yes">        </span>libDict.addWord(self, noun, &amp;noun);</pre><pre><span style="mso-spacerun: yes">        </span>libDict.addWord(self, adjective, &amp;adjective);</pre><pre><span style="mso-spacerun: yes">        </span>libDict.addWord(self, plural, &amp;plural);</pre><pre><span style="mso-spacerun: yes">    </span>}</pre><pre>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>As long as each class derived from
Thing (or from subclasses of Thing) properly inherits its superclass
constructor from its own constructor, the library code will take care of adding
the vocabulary words for the new instance, taking advantage of the accessibility
of the dictionary property values that TADS 3 provides.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><b>Dictionary vs. LookupTable:<span style="mso-spacerun:
yes">  </span></b>The Dictionary class is in some ways similar to the <a
href="t3lookup.htm">LookupTable</a> intrinsic class, in that both objects allow
you to associate keys with values and efficiently look up a value by key.<span
style="mso-spacerun: yes">  </span>However, Dictionary is considerably more
specialized than the general-purpose LookupTable: Dictionary allows multiple
values to be associated with a key, and provides the composite property/string
key.<span style="mso-spacerun: yes">    </span>Dictionary is also designed
specifically to store its specialized data, and makes more efficient use of
memory than a more general implementation would.<span style="mso-spacerun:
yes">  </span>In addition, Dictionary allows the string comparison rules to be
customized through the comparator object.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

</div>

</body>

</html>

<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./t3bytarr_files/filelist.xml">
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Merkin Muffley</o:Author>
  <o:LastAuthor>Dell User</o:LastAuthor>
  <o:Revision>17</o:Revision>
  <o:TotalTime>63</o:TotalTime>
  <o:Created>2001-06-08T06:40:00Z</o:Created>
  <o:LastSaved>2003-07-16T02:47:00Z</o:LastSaved>
  <o:Pages>3</o:Pages>
  <o:Words>1434</o:Words>
  <o:Characters>8179</o:Characters>
  <o:Lines>68</o:Lines>
  <o:Paragraphs>16</o:Paragraphs>
  <o:CharactersWithSpaces>10044</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>125</w:Zoom>
  <w:DrawingGridHorizontalSpacing>6 pt</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>6 pt</w:DrawingGridVerticalSpacing>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:AutoSpaceLikeWord95/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:13.0pt;
	font-family:Arial;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
tt
	{mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:1857107;
	mso-list-type:hybrid;
	mso-list-template-ids:138860130 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l1
	{mso-list-id:1047946470;
	mso-list-type:hybrid;
	mso-list-template-ids:182112854 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l2
	{mso-list-id:1465151244;
	mso-list-type:hybrid;
	mso-list-template-ids:-447453980 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l2:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<h3>The ByteArray Intrinsic Class</h3>

<p class=MsoNormal>Most TADS programs work with the high-level types that TADS
provides – integers, strings, lists, objects, and so on.<span
style="mso-spacerun: yes">  </span>In some cases, though, it's necessary to manipulate
the raw bytes that form the basic units of storage on modern computers.<span
style="mso-spacerun: yes">  </span>The ByteArray class provides a structured
way of working directly with bytes.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>A ByteArray looks superficially similar to a <a
href="t3vector.htm">Vector</a> object, in that you can access the individual
byte elements of a ByteArray using the square bracket indexing operator:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>local arr = new ByteArray(100);</pre><pre><span style="mso-spacerun: yes">  </span>arr[5] = 12;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note, though, that the elements of a
ByteArray can only store byte values, which are represented as integers in the
range 0 to 255.</p>

<h3 style='tab-stops:.5in'>Creating a ByteArray</h3>

<p class=MsoNormal style='tab-stops:.5in'>You create a ByteArray object using
the <tt><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>new</span></tt>
operator.<span style="mso-spacerun: yes">  </span>You must pass to the
constructor the number of bytes you want to allocate for the new object; this
can be any value from 1 to approximately 2 billion.<span style="mso-spacerun:
yes">  </span>For example, to create a byte array with 1,024 elements, you
would write this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>local arr = new ByteArray(1024);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The size of a ByteArray is fixed at
creation; the size cannot change after the object is created.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>You can also create a ByteArray as a
copy of another byte array or a portion of another byte array:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>arr = new ByteArray(otherArray, startIndex, len);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>startIndex</i> and <i>len</i>
parameters are optional; if they're missing, the new byte array will simply be
a complete copy of the existing byte array.<span style="mso-spacerun: yes"> 
</span>If <i>startIndex</i> and <i>len</i> are provided, the new array will be
a copy of the region of the other byte array starting at index <i>startIndex</i>
and continuing for <i>len</i> bytes.<span style="mso-spacerun: yes">  </span>If
<i>startIndex</i> is specified but <i>len</i> is missing, the new array will
consist of all of the bytes from the original starting with <i>startIndex</i>
and continuing to the end of the original array.</p>

<h3 style='tab-stops:.5in'>Reference Semantics</h3>

<p class=MsoNormal style='tab-stops:.5in'>Like regular <a href="t3array.htm">Array</a>
objects, a ByteArray has reference semantics: when you change a value in a byte
array, any other variables that refer to the same ByteArray will refer to the
modified version of the array.</p>

<h3 style='tab-stops:.5in'>Reading and Writing Raw Files</h3>

<p class=MsoNormal style='tab-stops:.5in'>One of the tasks for which ByteArray
objects are uniquely suited is working with files stored in a format defined by
another application.<span style="mso-spacerun: yes">  </span>Using ByteArray
objects, you can work directly with the exact bytes stored in an external file,
allowing you to process data in arbitrary binary formats.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>To read or write a file using
ByteArray objects, you must open the file in &quot;raw&quot; mode.<span
style="mso-spacerun: yes">  </span>Once a file is opened in raw mode, you can
use the fileRead() and fileWrite() methods to read bytes from the file into a
ByteArray and to write bytes from a ByteArray into the file.<span
style="mso-spacerun: yes">  </span>Refer to the <a href="t3tadsio.htm">&quot;tads-io&quot;
intrinsic function set</a> for information on the file input/output functions.</p>

<h3 style='tab-stops:.5in'>ByteArray Methods</h3>

<p class=MsoNormal style='tab-stops:.5in'><b>copyFrom(<i>sourceArray</i>, <i>sourceStartIndex</i>,
<i>destStartIndex</i>,<i> length</i>) – </b>copies bytes from <i>sourceArray</i>,
which must be another ByteArray object.<span style="mso-spacerun: yes"> 
</span>Copies bytes starting with the byte in <i>sourceArray</i> indexed by <i>sourceStartIndex</i>,
and continuing for <i>length</i> bytes; stores the bytes in this array starting
at the byte indexed by <i>destStartIndex</i>.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This routine is safe to use even if <i>sourceArray</i>
is the same as the target object, even if the ranges overlap.<span
style="mso-spacerun: yes">  </span>When copying bytes between overlapping
regions of the same array, this routine is careful to move the bytes without
overwriting any source bytes before they've been moved.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>fillValue(<i>val</i>, <i>startIndex</i>?,
<i>length</i>?) – </b>stores the value <i>val</i> in each element of the array,
starting at index <i>startIndex</i> and filling the next <i>length</i>
bytes.<span style="mso-spacerun: yes">  </span>If <i>startIndex</i> and <i>length</i>
are missing, <i>val</i> is stored in every element of the array.<span
style="mso-spacerun: yes">  </span>If <i>startIndex</i> is given but <i>length</i>
is missing, <i>val</i> is stored in every element from <i>startIndex</i> to the
end of the array.<span style="mso-spacerun: yes">  </span>The value <i>val </i>must
be an integer in the range 0 to 255.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>length()</b> – returns the number
of bytes in the ByteArray.<span style="mso-spacerun: yes">  </span>This is the
same as the size specified when the object was created.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><a name=mapToString></a><b>mapToString(<i>charset,
startIndex</i>?<i>, length</i>?) – </b>maps the bytes in the array to a Unicode
string, interpreting the bytes as belonging to the character set given by <i>charset</i>,
which must be an object of class <a href="t3cset.htm">CharacterSet</a>.<span
style="mso-spacerun: yes">  </span>Returns a string with the result of the
character mapping.<span style="mso-spacerun: yes">  </span>Only the bytes
starting at index <i>startIndex</i> and running for <i>length</i> bytes are
included in the mapping.<span style="mso-spacerun: yes">  </span>If <i>startIndex</i>
and <i>length</i> are missing, all of the bytes in the array are mapped.<span
style="mso-spacerun: yes">  </span>If <i>startIndex</i> is given but <i>length</i>
is missing, the bytes from <i>startIndex</i> to the end of the array are
included in the mapping.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The character set given by <i>charset</i>
must be known.<span style="mso-spacerun: yes">  </span>If the character set is
not known, an UnknownCharSetException is thrown.<span style="mso-spacerun:
yes">  </span>You can determine if the character set is known using the
isMappingKnown() method of <i>charset</i>.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>readInt(<i>startIndex, format</i>)
– </b>translates bytes from the byte array into an integer value.<span
style="mso-spacerun: yes">  </span>Reads from the byte array starting at the
byte given by <i>startIndex</i>, and reads the number of bytes implied by the
format code given by <i>format</i>, which also indicates how the bytes should
be interpreted into an integer value.<span style="mso-spacerun: yes"> 
</span>The return value is the integer value read and translated from the byte
array.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The format code given by <i>format</i>
is a bit-wise combination of three parts: a size, a byte order, and a
signedness:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l1 level1 lfo1;tab-stops:.5in'>The size gives
     the number of bits in the integer; this can be one of the values FmtSize8,
     FmtSize16, or FmtSize32, indicating 8-bit, 16-bit, and 32-bit values,
     respectively.<i><o:p></o:p></i></li>
 <li class=MsoNormal style='mso-list:l1 level1 lfo1;tab-stops:.5in'>The byte
     order can be FmtBigEndian or FmtLittleEndian.<span style="mso-spacerun:
     yes">  </span>A big-endian value is stored with its most significant byte
     first, followed by the second-most significant byte, and so on.<span
     style="mso-spacerun: yes">  </span>A little-endian value is stored in the
     opposite order, with its least significant byte first.<span
     style="mso-spacerun: yes">  </span>The readInt() method makes it possible to
     specify the desired byte ordering because the native byte ordering of
     different hardware platforms varies, and as a result, the ordering of
     bytes in data fields in file formats specified by third-party applications
     can vary.<span style="mso-spacerun: yes">  </span>Note that the byte order
     is irrelevant in the case of 8-bit values, since an 8-bit value requires
     only one byte in the byte array.<i><o:p></o:p></i></li>
 <li class=MsoNormal style='mso-list:l1 level1 lfo1;tab-stops:.5in'>The
     signedness indicates whether the integer is to be interpreted as signed or
     unsigned; this can be FmtSigned or FmtUnsigned.<span style="mso-spacerun:
     yes">  </span>Note that the T3 VM doesn't have an unsigned 32-bit
     datatype, so FmtUnsigned isn't meaningful with FmtSize32.<i><o:p></o:p></i></li>
</ul>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>So, to specify a signed 16-bit value
in big-endian byte order, you'd use (FmtSize16 | FmtSigned | FmtBigEndian).</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>It's a lot of typing to specify all
three parts of a data format, so the byte array system header file defines all
of the useful combinations as individual macros:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l2 level1 lfo2;tab-stops:.5in'>FmtInt8
     (signed 8-bit integer)</li>
 <li class=MsoNormal style='mso-list:l2 level1 lfo2;tab-stops:.5in'>FmtUInt8
     (unsigned 8-bit integer)</li>
 <li class=MsoNormal style='mso-list:l2 level1 lfo2;tab-stops:.5in'>FmtInt16LE
     (signed 16-bit integer in little-endian byte order)</li>
 <li class=MsoNormal style='mso-list:l2 level1 lfo2;tab-stops:.5in'>FmtUInt16LE
     (unsigned 16-bit integer in little-endian byte order)</li>
 <li class=MsoNormal style='mso-list:l2 level1 lfo2;tab-stops:.5in'>FmtInt16BE
     (signed 16-bit integer in big-endian byte order)</li>
 <li class=MsoNormal style='mso-list:l2 level1 lfo2;tab-stops:.5in'>FmtUInt16BE
     (unsigned 16-bit integer in big-endian byte order)</li>
 <li class=MsoNormal style='mso-list:l2 level1 lfo2;tab-stops:.5in'>FmtInt32LE
     (signed 32-bit integer in little-endian byte order)</li>
 <li class=MsoNormal style='mso-list:l2 level1 lfo2;tab-stops:.5in'>FmtInt32BE
     (signed 32-bit integer in big-endian byte order)</li>
</ul>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This function simply reads the bytes
out of the byte array and translates them according to the format
specification.<span style="mso-spacerun: yes">  </span>There is no information
in the byte array itself that indicates how the bytes are to be interpreted
into an integer, so it is up to your program to specify the correct format
translation.<span style="mso-spacerun: yes">  </span>You'll get strange results
if you attempt to read values in a format different from the format that was used
to write them.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>subarray(<i>startIndex</i>, <i>length</i>?)
– </b>returns a new ByteArray consisting of the region of this array starting
with the byte indexed by <i>startingIndex</i> of the number of bytes given by <i>length</i>.<span
style="mso-spacerun: yes">  </span>If <i>length</i> is not supplied, the new
ByteArray consists of all of the bytes from <i>startingIndex</i> to the last
byte of this array.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>writeInt(<i>startIndex, format,
val</i>) – </b>translates an integer value into a series of bytes, and writes
the bytes into the array.<span style="mso-spacerun: yes">  </span>The bytes are
written starting at the index given by <i>startIndex</i>.<span
style="mso-spacerun: yes">  </span>The number of bytes written is the byte size
implied by the format code given by <i>format</i>.<span style="mso-spacerun:
yes">  </span>The <i>val</i> argument gives the integer value to be written.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The format code in <i>format</i> has
the same meaning as the format code in readInt().</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note that this method doesn't perform
any range checking on <i>val</i>.<span style="mso-spacerun: yes">  </span>If <i>val</i>
is outside of the limits that can be represented with the specified format
code, this method will simply truncate the value stored to its low-order
portion, discarding any high-order bits that won't fit the format.<span
style="mso-spacerun: yes">  </span>For example, if you attempt to store 1000 in
an unsigned 8-bit format, the value stored would be 232; we can see this more
easily by noting that 1000 is 3E8 in hexadecimal, so when we truncate this to 8
bits, we get E8 in hex, which is 232 in decimal.<span style="mso-spacerun:
yes">  </span>Note also that if you later attempted to read this value back as
a <i>signed</i> 8-bit value, the result would be even stranger: it would be –24.<span
style="mso-spacerun: yes">  </span>This is because E8 is negative when
interpreted as signed, so it would be interpreted as the integer 0xFFFFFFE8,
which is –24.<span style="mso-spacerun: yes">  </span>If you need range
checking, your program must provide it.<span style="mso-spacerun: yes"> 
</span>Here are the limits of the different types:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>Signed
     8-bit: <span style="mso-spacerun: yes"> </span>-128 to 127</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>Unsigned
     8-bit:<span style="mso-spacerun: yes">  </span>0 to 255</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>Signed
     16-bit:<span style="mso-spacerun: yes">  </span>-32768 to 32767</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>Unsigned
     16-bit:<span style="mso-spacerun: yes">  </span>0 to 65535</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>Signed
     32-bit:<span style="mso-spacerun: yes">  </span>-2147483648 to 2147483647</li>
</ul>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The capacity of a type doesn't depend
on its byte order.<span style="mso-spacerun: yes">  </span>Note that there
should be no need for range checking on a 32-bit value, since the T3 VM's
internal integer type itself is a 32-bit signed value and thus can't exceed
this range to begin with.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This method stores only the bytes of the
translated integer value.<span style="mso-spacerun: yes">  </span>It doesn't
store any information on the format code used to generate the value; this means
that if you later want to read the integer value back out of the byte array, it
will be up to your program to specify the correct format code.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

</div>

</body>

</html>

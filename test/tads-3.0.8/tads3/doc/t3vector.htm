<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./t3vector_files/filelist.xml">
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Merkin Muffley</o:Author>
  <o:LastAuthor>Dell User</o:LastAuthor>
  <o:Revision>56</o:Revision>
  <o:TotalTime>142</o:TotalTime>
  <o:Created>2000-05-20T22:11:00Z</o:Created>
  <o:LastSaved>2003-07-13T20:51:00Z</o:LastSaved>
  <o:Pages>6</o:Pages>
  <o:Words>3995</o:Words>
  <o:Characters>22777</o:Characters>
  <o:Lines>189</o:Lines>
  <o:Paragraphs>45</o:Paragraphs>
  <o:CharactersWithSpaces>27971</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>125</w:Zoom>
  <w:DrawingGridHorizontalSpacing>6 pt</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>6 pt</w:DrawingGridVerticalSpacing>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:AutoSpaceLikeWord95/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:13.0pt;
	font-family:Arial;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
tt
	{mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:1733847351;
	mso-list-type:hybrid;
	mso-list-template-ids:2059048740 67698691 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:o;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<h3>The Vector Intrinsic Class</h3>

<p class=MsoNormal>Vector is a subclass <a href="t3array.htm">Collection</a>
that combines the provides an ordered collection of elements, like <a
href="t3list.htm">List</a>, but provides “<a href="#_Reference_Semantics">reference
semantics</a>,” which means that you can modify the elements of a Vector
directly.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>To use vectors, you must define the Vector intrinsic class
in your source code.<span style="mso-spacerun: yes">  </span>The easiest way to
do this is to include the system header &quot;vector.h&quot;, which is included
with the compiler.</p>

<h3>Which should I use: List or Vector?</h3>

<p class=MsoNormal>The List and Vector classes are very similar; both of these
classes allow you to manage collections of values as a group.<span
style="mso-spacerun: yes">  </span>The differences between the classes are a
little subtle, but they're important.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Lists offer two unique features.<span style="mso-spacerun:
yes">  </span>First, List is an intrinsic T3 VM datatype, which makes it the
&quot;universal&quot; collection type; some functions and methods require list
values, and will not accept other collection types.<span style="mso-spacerun:
yes">  </span>Second, Lists use &quot;<a href="t3list.htm#valueSemantics">value
semantics</a>,&quot; so you never have to worry about the effects of changing a
list value to which other parts of your program might be retaining references.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Vectors use &quot;reference semantics,&quot; which are
sometimes trickier to work with than a List's value semantics, but offer
advantages in some situations.<span style="mso-spacerun: yes"> 
</span>Reference semantics also make Vectors more efficient when you're
performing an iterative process that involves repeated updates to a
collection's elements: if you use a List for such a process, each update to an
element would create a new list value, whereas changes to a Vector's elements
simply change the existing Vector object, rather than creating a new Vector.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>In general, you can decide which type of collection to use
based on what you're going to do with it:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=circle>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>If
     you're storing a value that will be used by many parts of your program,
     such as in an object property, and the value won't be changed frequently,
     List is a good choice.<span style="mso-spacerun: yes">  </span>Because of
     a list's value semantics, the different parts of the code that refer to
     the same list won't have to coordinate their activities if they make local
     changes to the list.</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>If
     you'll be updating the elements of a collection frequently, you should use
     a Vector.<span style="mso-spacerun: yes">  </span>Using a Vector rather
     than a List avoids the overhead of creating a new copy of the collection
     every time you update one of its members.</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo3;tab-stops:list .5in'>If you
     are dynamically building a collection through an iterative process that
     involves repeated changes to the collection (additions of new elements,
     removal of elements, or updates to existing element values), you should
     use a Vector.</li>
</ul>

<h3>Creating a Vector</h3>

<p class=MsoNormal>To create a Vector, you use the &quot;new&quot;
operator.<span style="mso-spacerun: yes">  </span>You must pass an integer
argument to the Vector constructor; this is an advisory value specifying the
initial allocation size for the Vector.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>// create a Vector with an initial allocation of 10 elements</pre><pre><span style="mso-spacerun: yes">   </span>x = new Vector(10);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>In addition, you can pass an optional
second argument giving a List or Vector value to copy into the new Vector
object.<span style="mso-spacerun: yes">  </span>If this optional second
argument is present, the new Vector is initialized with the elements from the
argument:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>x = new Vector(10, [1, 2, 3]);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Alternatively, you can pass an
integer as the second argument, in which case the vector will be initialized with
the given number of <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>nil</span></tt> elements:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>x = new Vector(10, 10);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The initial allocation size does <i>not
</i>set an immutable upper bound for the number of elements in the Vector, nor
does it specify the initial number of elements; this is purely an advisory
figure that lets you make the Vector more efficient by providing a guess about
how big the Vector might ultimately be.<span style="mso-spacerun: yes"> 
</span>If you add elements to the Vector later that exceed the initial allocation,
the system will automatically expand the Vector’s memory allocation as needed
to accommodate the new elements.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If no source list/vector is specified
with the &quot;new&quot; operator, a newly created Vector has zero elements,
regardless of the initial allocation size.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>x = new Vector(100);</pre><pre><span style="mso-spacerun: yes">   </span>say(x.length());</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The code above displays zero, because
a Vector never has any elements initially.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>x = new Vector(1);</pre><pre><span style="mso-spacerun: yes">   </span>x += 1;</pre><pre><span style="mso-spacerun: yes">   </span>x += 2;</pre><pre><span style="mso-spacerun: yes">   </span>x += 3;</pre><pre><span style="mso-spacerun: yes">   </span>say(x.length());</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The above code displays 3, because
three elements have been added to the vector.<span style="mso-spacerun: yes"> 
</span>This is perfectly legal; even though the vector's initial allocation
size is only 1, you can still add any number of elements to the vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>So, if the initial allocation size
doesn't set the initial number of elements in the vector, and it doesn't set a
maximum size for the vector, what good is it, and what does it matter what the
value is?<span style="mso-spacerun: yes">  </span>The answer is that the
initial allocation size is purely advisory, and affects the memory efficiency
of the vector.<span style="mso-spacerun: yes">  </span>When you first create
the vector, the system internally allocates the number of slots you specify in
the initial allocation size; these slots are marked as &quot;not yet in
use,&quot; because the vector contains no elements at this point, but they're
available for future use when you add elements.<span style="mso-spacerun:
yes">  </span>Later, if you add more elements than there are slots available,
the vector automatically re-allocates its memory at a larger size.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If you make the initial allocation
size too small, the system will have to re-allocate the vector's memory,
possibly more than once, as you add new elements.<span style="mso-spacerun:
yes">  </span>If you make the initial allocation too large, the vector will
take up more memory than it will ever actually need.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Don't worry about this too much,
though.<span style="mso-spacerun: yes">  </span>TADS 3 manages memory for you
automatically, so it is not too dire a problem if your initial allocation is
too high or too low.<span style="mso-spacerun: yes">  </span>Any loss in
efficiency resulting from an inaccurate initial allocation size will be fairly
small.<span style="mso-spacerun: yes">  </span>This parameter is provided only
so that you can fine-tune your program's performance in cases where you have a
pretty good idea in advance of how large a vector will be; in cases where you
don't have any way of knowing, just pick a number that seems in the ballpark
for a typical case.</p>

<h3 style='tab-stops:.5in'>Vector Operators</h3>

<p class=MsoNormal style='tab-stops:.5in'>The &quot;+&quot; operator adds new
elements to the end of a Vector.<span style="mso-spacerun: yes">  </span>If the
operand on the right side of the &quot;+&quot; is a list or another Vector, its
elements are individually added to the vector; otherwise, the value on the
right side of the &quot;+&quot; is added as a single new element.<span
style="mso-spacerun: yes">  </span>Note that this operator always creates a new
Vector to store the result; the original vector’s value is unchanged.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The &quot;-&quot; operator removes
elements from the Vector.<span style="mso-spacerun: yes">  </span>If the
operand on the right side of the &quot;-&quot; is a list or Vector, each
element of the list of Vector is individually removed from the Vector on the
left of the &quot;-&quot;.<span style="mso-spacerun: yes">  </span>If the
operand on the right side of the &quot;-&quot; is not a list or vector, each
element of the vector whose value equals the right operand is deleted from the
vector on the left.<span style="mso-spacerun: yes">  </span>Note that the
&quot;-&quot; operator always creates a new Vector to store the result.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The indexing operator &quot;[<i>idx</i>]&quot;
can be used to get and set elements of the array using an integer index, just
as with a List.<span style="mso-spacerun: yes">  </span>If you assign an
element of the vector past the current length of the vector, the vector is
automatically extended to include the necessary number of elements; new
elements between the last existing element and the element at the requested
index are set to nil.<span style="mso-spacerun: yes">  </span>If you try to
retrieve a vector element with an index higher than any existing element, a
run-time exception (index out of range) is thrown.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>A Vector can be used with the
&quot;==&quot; or &quot;!=&quot; operators to compare a Vector to another
value.<span style="mso-spacerun: yes">  </span>A Vector is equal to another
Vector or List if the other Vector or List has the same number of elements, and
each element of the Vector equals the corresponding element of the other Vector
or List, using the same rules as the &quot;==&quot; operator to compare the
elements.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>Note: </b>Because the
&quot;==&quot; test is defined recursively, if a Vector contains a reference to
itself, either directly or indirectly through another Vector, the &quot;==&quot;
test can recurse infinitely.<span style="mso-spacerun: yes">  </span>The Vector
class avoids this infinite recursion by limiting the depth of recursion in an
equality comparison to 256 levels.<span style="mso-spacerun: yes">  </span>If
this recursion depth is exceeded, the &quot;==&quot; test throws an exception
(&quot;maximum equality test/hash recursion depth exceeded&quot;).<span
style="mso-spacerun: yes">  </span>This same exception will result, for the
same reason, if a Vector with a self-reference is used as a key in a
LookupTable.<span style="mso-spacerun: yes">  </span>The recursion depth exception
can occur even if a Vector contains no self-references, if it simply contains
such a complex series of references that it exceeds the maximum depth.<span
style="mso-spacerun: yes">  </span>Note that this limit does <b>not</b> have
anything to do with the number of elements in any Vector; rather, it pertains
to the depth of the references from one Vector to another.<span
style="mso-spacerun: yes">  </span>So, if you create Vectors A, B, C, D, …, and
set A[1] = B, B[1] = C, C[1] = D, and so on for more than 256 vectors, then
comparing A to another vector could exceed the maximum depth.</p>

<h3 style='tab-stops:.5in'>Vector Methods</h3>

<p class=MsoNormal style='tab-stops:.5in'>Vector is a subclass of <a
href="t3coll.htm">Collection</a>, so the Collection methods are available on a
Vector object.<span style="mso-spacerun: yes">  </span>In addition to the
Collection methods, Vector provides many methods of its own, shown below.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>append(<i>val</i>) – </b>appends
the value <i>val</i> to the end of the vector, increasing the vector's length
by one.<span style="mso-spacerun: yes">  </span>This method has almost the same
effect as the &quot;+&quot; operator, except for the treatment if <i>val</i> is
a list: this method simply appends a list value as a single new element,
whereas the &quot;+&quot; operator appends each element of the list value as a
separate new element.<span style="mso-spacerun: yes">  </span>In addition,
unlike the &quot;+&quot; operator, this method modifies the 'self' object,
rather than creating a new object to store the result.<span
style="mso-spacerun: yes">  </span>Returns 'self'.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>appendAll(<i>val</i>)</b> – this
works like append(<i>val</i>), except that if <i>val</i> is a List or Vector,
each element of <i>val</i> is individually appended to the ‘self’ object.<span
style="mso-spacerun: yes">  </span>This method works like the &quot;+&quot;
operator, except that this method modifies the 'self' object, rather than
creating a new object to store the result.<span style="mso-spacerun: yes"> 
</span>Returns 'self'.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>appendUnique(<i>val</i>) – </b>appends
the elements of the list or Vector <i>val </i>to this vector; the vector is
modified so that it consists only of the unique elements of the
combination.<span style="mso-spacerun: yes">  </span>On return, any given value
will appear in the vector will appear only once.<span style="mso-spacerun:
yes">  </span>Like append() and appendAll(), this modifies the 'self' vector
directly.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>applyAll(<i>func</i>) – </b>for each
element of the vector, this method invokes the callback function <i>func</i>,
passing the current element as the single argument, then replaces the vector
element with the return value from the callback.<span style="mso-spacerun:
yes">  </span>This method does <i>not </i>create a new vector; rather, it modifies
the original vector.<span style="mso-spacerun: yes">  </span>This method
returns 'self' as the result value.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This method is useful for
transforming the elements of a vector by applying a modifier function.<span
style="mso-spacerun: yes">  </span>For example, if we have a vector of numbers,
we could use this method to multiply each number in the vector by two:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>x.applyAll({x: x*2});</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This method is also handy for
performing complex initializations on a new vector.<span style="mso-spacerun:
yes">  </span>For example, here's a function that creates a new vector and
initializes it with the first <i>n </i>Fibonacci numbers.<span
style="mso-spacerun: yes">  </span>Because we're simply initializing the new
vector, note that the callback function doesn't make any reference to the
original element value, but it must still declare a parameter for the argument
value so that the arguments passed from applyAll() match the declaration.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>createFibonacciVector(n)</pre><pre><span style="mso-spacerun: yes">  </span>{</pre><pre><span style="mso-spacerun: yes">    </span>local f0 = f1 = 1;</pre><pre><span style="mso-spacerun: yes">    </span>return new Vector(n, n).applyAll(new function(x)</pre><pre><span style="mso-spacerun: yes">      </span>{ local ret = f0; f0 = f1; f1 += ret; return ret; });</pre><pre><span style="mso-spacerun: yes">  </span>}</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style='font-family:"Times New Roman"'>Note that we specify the value 'n' twice in the constructor to explicitly set the initial size of the vector to 'n' nil elements.<span style="mso-spacerun: yes">  </span>This is important because a newly-created vector normally doesn't contain any elements, regardless of the initial allocation setting; by explicitly using the initial length argument 'n', we ensure that applyAll() will visit 'n' elements.<o:p></o:p></span></pre>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>copyFrom(<i>source, sourceStart,
destStart, count</i>) – </b>copies values from a list or from another list or
vector into this vector.<span style="mso-spacerun: yes">  </span>This function
doesn't create a new vector, but simply modifies entries in the 'self'
vector.<span style="mso-spacerun: yes">  </span><i>source </i>is the source of
the values; it must be either a vector or a list.<span style="mso-spacerun:
yes">  </span><i>sourceStart</i> is an index into <i>source</i>, and specifies
the first element of <i>source </i>that is to be copied.<span
style="mso-spacerun: yes">  </span><i>destStart</i> is an index into the 'self'
vector, and specifies the first element of the vector that is to be
modified.<span style="mso-spacerun: yes">  </span><i>count</i> is the number of
elements to modify.<span style="mso-spacerun: yes">  </span>The method copies
elements from <i>source</i> into the 'self' vector, one at a time, until it
reaches the last element of <i>source</i>, or has copied the number of elements
specified by <i>count</i>.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Calling this method is equivalent to
writing a code fragment like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>for (local i = 0 ; i &lt; count ; ++i)</pre><pre><span style="mso-spacerun: yes">     </span>dest[destStart + i] = source[sourceStart + i];</pre>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'>If necessary, the method expands the
'self' vector to make room for the added elements.</p>

<p class=MsoNormal style='tab-stops:.5in'><span style="mso-spacerun:
yes"> </span></p>

<p class=MsoNormal style='tab-stops:.5in'>The copyFrom() method simply returns
'self'; this is convenient for expressions like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>x = new Vector(20).copyFrom(lst, 3, 2, 5);</pre>

<p class=MsoNormal style='margin-top:12.0pt;tab-stops:.5in'><b>countOf(<i>val</i>)
– </b>returns the number of elements in the vector whose values equal <i>val</i>.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>countWhich(<i>cond</i>) –</b>
returns the number of elements in the vector for which the callback function <i>cond
</i>returns a non-false value (anything but nil or 0).<span
style="mso-spacerun: yes">  </span>For each element in the vector, the method
invokes <i>cond</i>, passing the element as the argument to the callback.<span
style="mso-spacerun: yes">  </span>If <i>cond </i>returns anything but nil or
0, the method counts the element.<span style="mso-spacerun: yes">  </span>After
invoking <i>cond</i> for each element, the method returns the number of
elements for which <i>cond</i> returned a non-false value.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>fillValue(<i>value, start</i>?, <i>count</i>?)
– </b>fills elements of this vector with <i>value</i>.<span
style="mso-spacerun: yes">  </span>If only <i>value</i> is specified, this
method simply stores <i>value</i> in every element of the 'self' vector.<span
style="mso-spacerun: yes">  </span>If <i>start</i> is specified, it gives the
starting index; the method fills values starting with <i>start</i>, to the end
of the vector.<span style="mso-spacerun: yes">  </span>If both <i>start</i> and
<i>count</i> are specified, <i>count</i> gives the maximum number of elements
to fill.</p>

<pre><span style='font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre><pre><span
style='font-family:"Times New Roman"'>This method is equivalent to writing a code fragment like this:<o:p></o:p></span></pre><pre><span
style='font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre><pre><span style="mso-spacerun: yes">  </span>for (local i = 0 ; i &lt; count ; ++i)</pre><pre><span style="mso-spacerun: yes">    </span>dest[start + i] = value;</pre>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'>Calling fillValue() is easier than
writing this code fragment, though, and considerably faster because it is
implemented as native code.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This method returns 'self', which
allows for expressions like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>x = new Vector(20).fillValue('A', 1, 20);</pre>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><a name=findWhere></a><b>forEach(<i>func</i>)
– </b>invokes the callback function <i>func</i>(<i>value</i>) for each element,
in order from first to last, passing the value of one element as <i>value</i>
to the callback on each invocation.<span style="mso-spacerun: yes">  </span>The
callback function takes one argument giving the value of the current element,
and returns no value.<span style="mso-spacerun: yes">  </span>This method
returns no value.<span style="mso-spacerun: yes">  </span>This method is a
convenient means of executing some code for each element of the vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>forEachAssoc(<i>func</i>) – </b>invokes
the callback function <i>func</i>(<i>index, value</i>) for each element, in
order from first to last, passing each element's index and value to the
function <i>func</i>.<span style="mso-spacerun: yes">  </span>The callback
function returns no value.<span style="mso-spacerun: yes">  </span>This method
returns no value.<span style="mso-spacerun: yes">  </span>This method is the
same as forEach(), except that this method provides the callback with the index
as well as the value for each element it visits.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>getUnique() – </b>returns a new
vector consisting of the unique elements of the original vector.<span
style="mso-spacerun: yes">  </span>For each value in the original vector, the
value will appear in the new vector only once.<span style="mso-spacerun: yes"> 
</span>The order of the elements in the new vector is that of the first
appearances of the unique elements of the original vector.<span
style="mso-spacerun: yes">  </span>For example, if the original vector's
elements are, in order, 1, 5, 2, 5, 3, 5, 4, 5, this method will return a new vector
whose elements are, in order, 1, 5, 2, 3, 4.<span style="mso-spacerun: yes"> 
</span>Note that the size of the new vector is just large enough to hold only
the unique elements, so the new vector might be smaller than the original
vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>indexOf(<i>val</i>) – </b>finds
the first element of the vector whose value equals <i>val</i>, and returns the
index of the element.<span style="mso-spacerun: yes">  </span>Returns nil if
none of the vector's elements equals <i>val</i>.<b><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>indexWhich(<i>cond</i>) – </b>finds
the first element for which the given condition is true.<span
style="mso-spacerun: yes">  </span>The method iterates through the elements of
the vector, starting at the first element and proceeding in order, and applies
the callback function <i>cond</i> to each element.<span style="mso-spacerun:
yes">  </span>The callback takes one argument, which is the value of the vector
element, and returns a condition result value.<span style="mso-spacerun: yes"> 
</span>For each element, if the callback function returns a non-false value
(i.e., any value except nil or zero), the method immediately stops the
iteration and returns the index of that element.<span style="mso-spacerun:
yes">  </span>If the callback returns a false value (nil or zero) for every
element of the vector, the method returns nil.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>insertAt(<i>startingIndex, val, …</i>)
– </b>inserts one or more values into the vector at the giving starting
index.<span style="mso-spacerun: yes">  </span>The size of the vector is
increased to accommodate the new elements.<span style="mso-spacerun: yes"> 
</span>Note that, if any of the values are lists or other collections, they are
simply inserted as single elements; this contrasts with the &quot;+&quot;
operator, which adds each element of a list as a separate element of the
vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>startingIndex</i> value must
be at least 1, and at most one higher than the length of the vector.<span
style="mso-spacerun: yes">  </span>If the starting index value is 1, the new
elements are inserted before the first existing element of the vector.<span
style="mso-spacerun: yes">  </span>If the starting index is one higher than the
length of the vector, the new elements are appended after the last existing
element of the vector.<span style="mso-spacerun: yes">  </span>If the starting
index is out of this valid range, the method throws an error (&quot;index out
of range&quot;).</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Returns the 'self' object.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>lastIndexOf(<i>val</i>) – </b>returns
the index of the last element in the vector whose value equals <i>val</i>.<span
style="mso-spacerun: yes">  </span>If none of the elements in the vector
matches the given value, the method returns nil.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>lastIndexWhich(<i>cond</i>) – </b>finds
the last element for which the given condition is true.<span
style="mso-spacerun: yes">  </span>This method is similar to indexWhich(<i>cond</i>),
but scans the vector in reverse order, starting with the last element and
working backwards.<span style="mso-spacerun: yes">  </span>Returns the index of
the matching element, or nil if the condition returns false for every element.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>lastValWhich(<i>cond</i>) – </b>finds
the last element for which the given condition is true, and returns the element's
value.<span style="mso-spacerun: yes">  </span>This method is similar to
lastIndexWhich(<i>cond</i>), but returns the value of the matching element
rather than its index.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>length() – </b>returns an integer
giving the number of elements in the vector.<span style="mso-spacerun: yes"> 
</span>This is the number of elements actually stored in the vector, and is
unrelated to the initial allocation size specified when the vector was created.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>mapAll(<i>func</i>) – </b>creates
a new vector consisting of the results of applying the callback function <i>func
</i>to each element of the original vector.<span style="mso-spacerun: yes"> 
</span>This method is similar to applyAll(<i>func</i>), but rather than
modifying the elements of the original vector, this method creates a new
vector, and leaves the elements of the original vector unchanged.<span
style="mso-spacerun: yes">  </span>The return value is the new vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>prepend(<i>val</i>) – </b>inserts the
value <i>val</i> before the first element of the vector, increasing the
vector’s length by one.<span style="mso-spacerun: yes">  </span>This method is
similar to append(<i>val</i>), but inserts the new element at the start of the
vector rather than at the end.<span style="mso-spacerun: yes">  </span>Returns
‘self’.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>removeElement(<i>val</i>) – </b>deletes
one or more elements from the vector; each vector element whose value equals <i>val</i>
is removed from the vector.<span style="mso-spacerun: yes">  </span>This
reduces the length of the vector by the number of elements removed.<span
style="mso-spacerun: yes">  </span>If there is no element of the vector whose
value equalss <i>val</i>, the vector is unchanged.<span style="mso-spacerun:
yes">  </span>Returns 'self'.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>removeElementAt(<i>index</i>) – </b>deletes
one element from the vector at the given index.<span style="mso-spacerun:
yes">  </span>This reduces the length of the vector by one.<span
style="mso-spacerun: yes">  </span>The <i>index </i>value must refer to an
existing element of the vector, or the method throws an error (&quot;index out
of range&quot;).<span style="mso-spacerun: yes">  </span>Returns 'self'.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><b>removeRange(<i>startingIndex,
endingIndex</i>) – </b>deletes elements from the vector from <i>startingIndex</i>
through and including <i>endingIndex</i>.<span style="mso-spacerun: yes"> 
</span>If <i>startingIndex </i>equals <i>endingIndex</i>, this method simply
deletes one element.<span style="mso-spacerun: yes">  </span>This reduces the
length of the vector by the number of elements removed.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Both <i>startingIndex</i> and <i>endingIndex</i>
must refer to existing elements of the vector, and the ending index must be
greater than or equal to the starting index; if these conditions don't hold,
the method throws an error (&quot;index out of range&quot;).</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Returns the &quot;self&quot; object.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>setLength(<i>newLength</i>) – </b>sets
the number of elements of the vector to <i>newLength</i>.<span
style="mso-spacerun: yes">  </span>If <i>newLength</i> is smaller than the
number of elements currently in the vector, this discards elements at the end
of the vector.<span style="mso-spacerun: yes">  </span>If <i>newLength</i> is
larger than the current size, this adds new elements and sets their values to
nil.<span style="mso-spacerun: yes">  </span>Returns the 'self' object.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>sort(<i>descending</i>?, <i>comparisonFunction</i>?)
– </b>re-orders the elements of the vector into sorted order.<span
style="mso-spacerun: yes">  </span>By default, this method sorts the elements
of the vector into ascending order, but you can reverse this ordering by
specifying true for the <i>descending </i>argument.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The optional <i>comparisonFunction </i>can
be used to specify the ordering of the result.<span style="mso-spacerun: yes"> 
</span>If this argument is not specified (or is nil), the method will sort the
elements according to the standard system ordering of values; hence, the
elements must be of comparable types (such as all integers or all
strings).<span style="mso-spacerun: yes">  </span>By specifying a comparison
function, you can provide your own special ordering, and you can also sort
values that have no system-defined order, such as object values.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>comparisonFunction </i>works
the same way as the for the <a href="t3list.htm#sort">List class's sort()
method</a>.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>subset(<i>func</i>) – </b>creates
and returns a new vector containing the elements of this vector for which the
callback function <i>func </i>returns true (i.e., any value other than nil or
the integer value 0).<span style="mso-spacerun: yes">  </span>For each element
of the source vector, this method invokes the callback function, passing the
value of the current element as the callback function's single argument.<span
style="mso-spacerun: yes">  </span>If the callback returns nil or the integer
value 0, the method omits the element from the result; otherwise, the method
includes the element in the result vector.<span style="mso-spacerun: yes"> 
</span>The new vector's elements will be in the same order as the selected
elements from the source vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This method does not modify the
original vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This example uses a short-form
anonymous function to create to create a new vector that contains only the
elements from an original vector whose values are greater than 10.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>y = x.subset({x: x &gt; 10});</pre>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>toList(<i>start</i>?, <i>count</i>?)
– </b>creates and returns a new list value based on the vector.<span
style="mso-spacerun: yes">  </span>With no arguments, the new list has the same
number of elements as the original vector, and each element of the list is a
copy of the corresponding element of the vector.<span style="mso-spacerun:
yes">  </span>If <i>start </i>is specified, it gives the starting index in the
vector for the list; elements of the vector before <i>start </i>are not included
in the list.<span style="mso-spacerun: yes">  </span>If <i>count </i>is
specified, it indicates the number of elements of the vector, starting at <i>start</i>,
to copy into the list.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This method is useful when you need
to pass a value to a routine that requires a list value.<span
style="mso-spacerun: yes">  </span>Vectors cannot always be passed to routines
requiring list values, so you can use this routine to create a list with the
same values as the vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This method does not modify the
vector.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'><b>valWhich(<i>cond</i>) – </b>returns
the value of the first element for which the callback function <i>cond</i> returns
a non-false value (i.e., any value other than nil or 0).<span
style="mso-spacerun: yes">  </span>The method applies the callback to each
element of the vector, starting with the first, and calls the function for each
element in turn until <i>cond</i> returns a non-false value.<span
style="mso-spacerun: yes">  </span>Returns nil if the callback returns a false
value for every element.<span style="mso-spacerun: yes">  </span>This function
is almost the same as indexWhich(<i>cond</i>), but returns the value of the
first element for which <i>cond </i>returns non-false rather than the index of
the element.</p>

<h3 style='tab-stops:.5in'><a name="_Reference_Semantics"></a>Reference
Semantics</h3>

<p class=MsoNormal style='tab-stops:.5in'>The most important distinction
between lists and vectors, and the primary reason to use vectors rather than
lists in certain situations, is that vectors use &quot;reference&quot;
semantics, while lists use &quot;value&quot; semantics.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The difference is that <i>a list's
value can never change</i>, but an vector's value <i>can</i> change.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>When you do something that modifies a
list, such as assigning a value to an element of the list, the operation does <i>not
</i>change the list.<span style="mso-spacerun: yes">  </span>Instead, it
creates a new list that reflects the change, leaving the original list
unmodified.<span style="mso-spacerun: yes">  </span>TADS automatically updates
the variable that contained the list being indexed so that it contains the
newly-created list.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>In contrast, when you assign a new
value to an element of an vector, the vector's value is changed.<span
style="mso-spacerun: yes">  </span>No new vector object is created.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This might seem like a very obscure
difference, but it has two important practical effects.<span
style="mso-spacerun: yes">  </span>The first is that operations that modify
vectors are much cheaper to execute, because they don't result in creating new
objects; this means that operations involving a large number of element changes
will run faster with vectors than with lists.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The second practical difference is
that, whenever you change a vector, the change is visible everywhere the vector
is referenced.<span style="mso-spacerun: yes">  </span>In contrast, when you change
a list, the change is visible only to the code that made the change.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Consider this example:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>local a = [1, 2, 3];</pre><pre><span style="mso-spacerun: yes">  </span>local b = a;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>a[2] = 100;</pre><pre><span style="mso-spacerun: yes">  </span>tadsSay(b[2]);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>What will this example display?<span
style="mso-spacerun: yes">  </span>At the beginning of the code, we set a to a list,
and then we set b to the value in a, so b refers to the same list.<span
style="mso-spacerun: yes">  </span>So far we have only one object, and both a
and b refer to this single object.<span style="mso-spacerun: yes">  </span>We
next assign a new value, 100, to the second element of a.<span
style="mso-spacerun: yes">  </span>As we've seen, this cannot change the list
that a refers to, because lists can never change; so, what we're doing is
creating a new list, copying each element from the original list to the new
list, but changing the second element to reflect the assignment.<span
style="mso-spacerun: yes">  </span>This new list is then assigned to a, so a
and b now refer to <i>different</i> lists.<span style="mso-spacerun: yes"> 
</span>So, when we display the second element of b, we see the value
&quot;2&quot; displayed, because b still refers to the original, unmodified
list.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Now, consider the same example with
an vector:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>local a = new Vector(10, [1, 2, 3]);</pre><pre><span style="mso-spacerun: yes">  </span>local b = a;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>a[2] = 100;</pre><pre><span style="mso-spacerun: yes">  </span>tadsSay(b[2]);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This code looks almost identical, but
it displays a different result than the list version.<span style="mso-spacerun:
yes">  </span>We start out by creating a new vector object and assigning it to
a, and then we assign the same value to b. <span style="mso-spacerun:
yes"> </span>Next, we assign 100 to the second element of a.<span
style="mso-spacerun: yes">  </span>Unlike lists, vectors can be changed, so
this assignment simply replaces the value in the vector object's second
element.<span style="mso-spacerun: yes">  </span>No new vector object is
created, so a and b still refer to the same object.<span style="mso-spacerun:
yes">  </span>So, when we display b[2] in this example, we see the modified
value. </p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Here's a more interesting example:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>f1()</pre><pre>{</pre><pre><span style="mso-spacerun: yes">  </span>local a = new Vector(3);</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>getInfo(a);</pre><pre><span style="mso-spacerun: yes">  </span>&quot;Thanks, &lt;&lt;a[1]&gt;&gt;!<span style="mso-spacerun: yes">  </span>This information will allow us to send</pre><pre><span style="mso-spacerun: yes">  </span>you specially targeted advertising based on your credit</pre><pre><span style="mso-spacerun: yes">  </span>history! &quot;;</pre><pre>}</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre>getInfo(x)</pre><pre>{</pre><pre><span style="mso-spacerun: yes">  </span>&quot;Please enter your name: &quot;; x[1] = input();</pre><pre><span style="mso-spacerun: yes">  </span>&quot;Please enter your age: &quot;; x[2] = toInteger(input());</pre><pre><span style="mso-spacerun: yes">  </span>&quot;Please enter your social security number: &quot;; x[3] = input();</pre><pre>}</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This is something we couldn't have done
with lists: assigning elements of x in getInfo() wouldn't have affected the
caller's copy of the list, so the routine wouldn't be able to pass back
information this way using lists.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note that, when you explicitly create
a copy of a vector, the new copy is not affected by any changes to the
original:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>x = new Vector(10, [1, 2, 3, 4, 5]);</pre><pre><span style="mso-spacerun: yes">  </span>y = new Vector(x);</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>x[3] = 100;</pre><pre><span style="mso-spacerun: yes">  </span>tadsSay(y[3]);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This example displays the value
&quot;3&quot; (<i>not </i>&quot;100&quot;), because x and y refer to separate
objects.<span style="mso-spacerun: yes">  </span>Changing a value in the vector
to which x refers has no effect on the vector to which y refers.</p>

</div>

</body>

</html>

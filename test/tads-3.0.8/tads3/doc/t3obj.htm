<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./t3obj_files/filelist.xml">
<link rel=Edit-Time-Data href="./t3obj_files/editdata.mso">
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Merkin Muffley</o:Author>
  <o:LastAuthor>Dell User</o:LastAuthor>
  <o:Revision>97</o:Revision>
  <o:TotalTime>569</o:TotalTime>
  <o:Created>2000-03-04T00:46:00Z</o:Created>
  <o:LastSaved>2004-03-12T21:38:00Z</o:LastSaved>
  <o:Pages>10</o:Pages>
  <o:Words>5288</o:Words>
  <o:Characters>30146</o:Characters>
  <o:Lines>251</o:Lines>
  <o:Paragraphs>60</o:Paragraphs>
  <o:CharactersWithSpaces>37021</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>125</w:Zoom>
  <w:DrawingGridHorizontalSpacing>6 pt</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>6 pt</w:DrawingGridVerticalSpacing>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:AutoSpaceLikeWord95/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	tab-stops:.5in;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:0pt;}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:13.0pt;
	font-family:Arial;}
p.MsoBodyTextIndent, li.MsoBodyTextIndent, div.MsoBodyTextIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
tt
	{mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:102921784;
	mso-list-type:hybrid;
	mso-list-template-ids:1253182326 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l1
	{mso-list-id:774250765;
	mso-list-type:hybrid;
	mso-list-template-ids:774824758 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<h3>Object Definitions</h3>

<p class=MsoNormal>TADS programs are made mainly of objects.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>An &quot;object&quot; is a data structure that groups
together a set of data values, called properties, and functions, called
methods.<span style="mso-spacerun: yes">  </span>Each property and each method
has a name, which is a symbol that you can use to refer to the property or
method from within the program.<span style="mso-spacerun: yes">  </span>An
object also has one or more &quot;superclasses&quot; (also called
&quot;base&quot; classes); the superclasses provide defaults for any properties
and methods that the object doesn't itself define but one or more of the
superclasses do.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>An object can be either &quot;static&quot; or
&quot;dynamic.&quot;<span style="mso-spacerun: yes">  </span>A static object is
one that is defined directly in your program's source code; it exists
throughout execution of the program.<span style="mso-spacerun: yes">  </span>A
dynamic object is one that is created in the course of the program's execution
with the &quot;new&quot; operator; it comes into existence when created with
&quot;new,&quot; and exists only as long as it is referenced by any local
variables or properties.<span style="mso-spacerun: yes">  </span>Once a dynamic
object is no longer referenced anywhere in the executing program, the system
automatically deletes the object, since it can no longer be used for anything.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Most TADS programs define numerous static objects, because
these objects encode the game world that the program implements.<span
style="mso-spacerun: yes">  </span>An object can represent a real-world object
that the game simulates, or a component of a real-world object, or an entirely
abstract programmatic entity.</p>

<h3>Basic Object Definition Syntax</h3>

<p class=MsoNormal>The most general way to define an object is like this:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span><i>objectName</i> : <i>class1</i>, <i>class2</i>, <i>class3</i></pre><pre><span style="mso-spacerun: yes">      </span><i>prop1</i> = <i>val1</i></pre><pre><span style="mso-spacerun: yes">      </span><i>prop2</i> = <i>val2<o:p></o:p></i></pre><pre><span style="mso-spacerun: yes">      </span><i>method1</i> ( <i>arg1, arg2 </i>) { <i>methodBody1 </i>}</pre><pre><span style="mso-spacerun: yes">      </span><i>method2 </i>( <i>arg1, arg2, arg3 </i>) { <i>methodBody2 </i>}<i><o:p></o:p></i></pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The first line names the object, and
defines its superclass list.<span style="mso-spacerun: yes">  </span>An object
must always have at least one superclass, but you can use the special class
name &quot;object&quot; if you want a generic object that is not based on
another object that your program defines.<span style="mso-spacerun: yes"> 
</span>Note, however, that if you use &quot;object&quot; as the superclass, it
must be the <i>only </i>superclass.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If you specify more than one
superclass, the order of the classes determines the inheritance order.<span
style="mso-spacerun: yes">  </span>The first (left-most) superclass has
precedence for inheritance, so any properties or methods that it defines effectively
override the same properties and methods defined in subsequent superclasses.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Alternatively, you can write the same
thing in a slightly different way, by enclosing the list of properties in
braces:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span><i>objectName</i> : <i>class1</i>, <i>class2</i>, <i>class3</i></pre><pre><span style="mso-spacerun: yes">   </span>{</pre><pre><span style="mso-spacerun: yes">      </span><i>prop1</i> = <i>val1</i></pre><pre><span style="mso-spacerun: yes">      </span><i>prop2</i> = <i>val2<o:p></o:p></i></pre><pre><span style="mso-spacerun: yes">      </span><i>method1</i> ( <i>arg1, arg2 </i>) { <i>methodBody1 </i>}</pre><pre><span style="mso-spacerun: yes">      </span><i>method2 </i>( <i>arg1, arg2, arg3 </i>) { <i>methodBody2 </i>}</pre><pre><span style="mso-spacerun: yes">   </span>}<i><o:p></o:p></i></pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>When you use this alternative syntax,
you must place the <i>entire </i>property list within the braces.<span
style="mso-spacerun: yes">  </span>A semicolon is <i>not </i>required at the
end of the object definition using this syntax, because the closing brace
unambiguously ends the definition.<span style="mso-spacerun: yes"> 
</span>(It's legal to add a semicolon after the closing brace, though, because
a semicolon by itself is always acceptable as an empty top-level
statement.)<span style="mso-spacerun: yes">  </span>You may optionally place a
semicolon after each property definition; the compiler simply ignores any such
semicolons, because it knows the property list doesn't end until the closing
brace.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The two object definition formats 
with braces or without  are identical in meaning; they differ only in
appearance.<span style="mso-spacerun: yes">  </span>You can use either format
for any object; the compiler automatically recognizes which form you're using
for each object.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The language allows the two formats
purely for your convenience.<span style="mso-spacerun: yes">  </span>Because of
the wide range of objects and classes that adventure game programs tend to
define, many objects tend to look better in one format or the other.<span
style="mso-spacerun: yes">  </span>Some authors might find that small objects
composed mostly of data look less cluttered and more compact without the
braces, while larger objects with lots of code benefit from the more visually
structured appearance of the brace format.<span style="mso-spacerun: yes"> 
</span>Other authors might simply prefer the brace format in all cases because
it's similar to Java and C++ notation.</p>

<h3 style='tab-stops:.5in'><a name=staticInit></a><a name=propertyset></a>Property
Sets</h3>

<p class=MsoNormal>In some situations, you'll need to define a group of related
properties and methods that share some common root name, and possibly some
common parameters as well.<span style="mso-spacerun: yes">  </span>This
situation sometimes occurs, for example, when you're using a library that
defines a naming convention for the methods that your code provides to handle
the individual processing steps for an event: all of the methods pertain to
different phases of the same event, so the library gives all of the methods a
common portion to their names to help make it clear that they're related.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The compiler provides a short-hand syntax that makes it
easier to define sets of properties with related names.<span
style="mso-spacerun: yes">  </span>The <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>propertyset</span></tt> keyword
introduces a group of property definitions, and specifies a pattern string that
defines the naming convention.<span style="mso-spacerun: yes">  </span>A
propertyset pattern string looks like a regular symbol name enclosed in single
quotes, except that it contains a single asterisk (&quot;*&quot;), which
specifies where the non-common part of the name goes.<span style="mso-spacerun:
yes">  </span>Everything else in the string is the common part of the names of
the properties in the set.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>For example, suppose you're using a library that defines a
set of method calls that process mouse clicks.<span style="mso-spacerun: yes"> 
</span>All of the mouse click methods have a common root name of
&quot;onMouse,&quot; but then add a suffix for the individual method:
onMouseDown, onMouseMove, onMouseUp.<span style="mso-spacerun: yes"> 
</span>For this set of names, the pattern string would be 'onMouse*' - the
asterisk at the end tells the compiler that the only part that differs from one
property to another is at the end of the string.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>After the <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>propertyset</span></tt> keyword and the
pattern string, you place a set of otherwise normal property definitions,
enclosed in a set of braces to mark the bounds of the set.<span
style="mso-spacerun: yes">  </span>So, the general syntax for a property set
is:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>propertyset '<i>pattern</i>'</pre><pre><span style="mso-spacerun: yes">  </span><span style="mso-spacerun: yes"> </span>{</pre><pre><span style="mso-spacerun: yes">      </span><i>property_list<o:p></o:p></i></pre><pre><span style="mso-spacerun: yes">   </span>}</pre>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Optionally, you can include a parameter list after the
pattern.<span style="mso-spacerun: yes">  </span>The parameter list is a set of
common formal parameters that each method in the set will have, in addition to
any parameters the individual methods define.<span style="mso-spacerun: yes"> 
</span>Like the name pattern, the parameter list uses an asterisk
(&quot;*&quot;) to indicate where the added parameters of each method go in the
list.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>propertyset 'pattern' (<i>params</i>, *, <i>params</i>) { <i>property_list</i> }</pre>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>This all goes within an object definition - you can put a
property set anywhere a single property could go, and property sets can be
intermingled with regular property definitions (so regular properties can come
before and after a property set).</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Here's an example, using the mouse events we proposed above:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>class myWindow: myWidget</pre><pre><span style="mso-spacerun: yes">  </span>x = 0</pre><pre><span style="mso-spacerun: yes">  </span>y = 0</pre><pre><span style="mso-spacerun: yes">  </span>width = 0</pre><pre><span style="mso-spacerun: yes">  </span>height = 0</pre><pre><span style="mso-spacerun: yes">  </span>propertyset 'onMouse*'</pre><pre><span style="mso-spacerun: yes">  </span>{</pre><pre><span style="mso-spacerun: yes">    </span>Down(x, y, clicks) { ... }</pre><pre><span style="mso-spacerun: yes">    </span>Move(x, y) { ... }</pre><pre><span style="mso-spacerun: yes">    </span>Up(x, y) { ... }</pre><pre><span style="mso-spacerun: yes">  </span>}</pre><pre>;</pre>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The property set syntax is essentially a textual
substitution facility, in that the compiler actually translates the properties
within the property set to their full names based no the pattern string.<span
style="mso-spacerun: yes">  </span>So, the definition of Down in the example
above is exactly the same as though it had been made outside of the property
set with a name of onMouseDown.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Property sets can also specify common parameters to the
methods defined within.<span style="mso-spacerun: yes">  </span>In the example
above, each method has the same first two parameters, x and y, so we can
further reduce the amount of typing by putting these common parameters in the
propertyset definition:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>propertyset 'onMouse*' (x, y, *)</pre><pre><span style="mso-spacerun: yes">  </span>{</pre><pre><span style="mso-spacerun: yes">    </span>Down(clicks) { ... }</pre><pre><span style="mso-spacerun: yes">    </span>Move { ... }</pre><pre><span style="mso-spacerun: yes">    </span>Up { ... }</pre><pre><span style="mso-spacerun: yes">  </span>}</pre>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The propertyset definition specifies that every item defined
within has x and y as the first two parameters, and that any additional
parameters go after the two common parameters.<span style="mso-spacerun: yes"> 
</span>So, the line that reads &quot;Down(clicks)&quot; actually defines
&quot;onMouseDown(x, y, clicks)&quot; after the propertyset definition is
expanded.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>You can put a propertyset definition inside another
propertyset definition.<span style="mso-spacerun: yes">  </span>Note, though,
that the fully-expanded property names within a propertyset must be legal
symbol names - in particular, they must fit within the 40-character limit for a
TADS identifier.</p>

<h3 style='tab-stops:.5in'>Static Property Initialization</h3>

<p class=MsoNormal>Most property initializations contain simple compile-time
constants, such as numbers or strings.<span style="mso-spacerun: yes"> 
</span>However, it is sometimes useful to be able to initialize a property to a
value that isn't a constant, but which you want computed once and stored.<span
style="mso-spacerun: yes">  </span>For example, you might want to use the
&quot;new&quot; operator to create an object and store a reference to it in a
property, but you want to do this just once when the program starts
running.<span style="mso-spacerun: yes">  </span>These types of initializations
are called &quot;static,&quot; because they don't change after the program
starts running.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The language provides a simple way to specify non-constant
static initializations.<span style="mso-spacerun: yes">  </span>In a property
definition, place the keyword &quot;static&quot; just before the value to be
computed:</p>

<pre><span style='font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre><pre><span style="mso-spacerun: yes">   </span>desk: object</pre><pre><span style="mso-spacerun: yes">     </span>topSurface = static new Surface()</pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>You can place any expression after
the &quot;static&quot; keyword.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The compiler evaluates all of the
static initializer expressions just before running <a href="t3libpre.htm">pre-initialization</a>.<span
style="mso-spacerun: yes">  </span>The compiler evaluates each static
initializer just once, and stores the result value in the property.<span
style="mso-spacerun: yes">  </span>When the property is evaluated at run-time,
the expression is <i>not </i>re-evaluated  the whole point is that the value
is computed once and stored.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note that static initializers only
run when pre-initialization runs.<span style="mso-spacerun: yes">  </span>So,
if you compile your program for debugging, the compiler won't execute the
static initializers, but will leave them for evaluation at the start of normal
execution.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The order in which the compiler
executes the static initializers is arbitrary; however, where there are
dependencies among static initializers, the compiler automatically performs the
initializations in the order required to resolve the dependencies correctly.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoBodyTextIndent style='tab-stops:.5in'>For the technically inclined,
the technique the compiler uses to resolve dependency ordering correctly is
fairly simple.<span style="mso-spacerun: yes">  </span>The compiler effectively
re-writes each static initializer like so:</p>

<p class=MsoNormal style='margin-left:.5in;tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='margin-left:.5in;tab-stops:.5in'><tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'><span
style="mso-spacerun: yes">   </span>prop = { self.prop = <i>expr</i>; return
self.prop; }<o:p></o:p></span></tt></p>

<p class=MsoNormal style='margin-left:.5in;tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='margin-left:.5in;tab-stops:.5in'>So, if the
expression references another property with a static initializer, it doesn't
matter whether or not that initializer has been executed yet.<span
style="mso-spacerun: yes">  </span>If it has, evaluating the property simply
retrieves the value that was already computed and stored in the property.<span
style="mso-spacerun: yes">  </span>If it hasn't, though, evaluating the
property not only evaluates the static initializer expression, but stores the
resulting value in the property; so, when the compiler does get around to
invoking that other static initializer, it finds the property has already been
initialized, so the extra invocation has no effect.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>You might note that static
initializers are purely a syntactic convenience, since you can do anything a
static initializer can do using the more general pre-initialization mechanism
instead.<span style="mso-spacerun: yes">  </span>However, there is one
practical difference worth noting: the code that is generated to execute the
expression of a static initializer is <i>not </i>included in the image
file.<span style="mso-spacerun: yes">  </span>The compiler knows that a static
initializer expression is only needed during the compilation phase, so it can
eliminate the code generated for the expression when producing the image
file.<span style="mso-spacerun: yes">  </span>The compiler can't make the same
assumption about pre-initialization code, since the same code could be invoked
again during normal execution.</p>

<h3 style='tab-stops:.5in'>Anonymous Objects</h3>

<p class=MsoNormal style='tab-stops:.5in'>In many cases, you will not have any need
to give an object a name when you define it.<span style="mso-spacerun: yes"> 
</span>The compiler accommodates these cases with the &quot;anonymous
object&quot; syntax.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>To define an object with no name,
simply start the definition with the class list.<span style="mso-spacerun:
yes">  </span>Everything else about the object definition is the same as for a
named object.<span style="mso-spacerun: yes">  </span>For example:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>Item sdesc = &quot;red box&quot; ;</pre><pre><span style="mso-spacerun: yes">   </span>Readable { sdesc = &quot;book&quot; }</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Because an anonymous object doesn't
have a symbol that you can use to refer to the object, you must use some other
mechanism to manipulate the object.<span style="mso-spacerun: yes">  </span>For
example, you can use the firstObj() and nextObj() functions, since iterations
with these functions include anonymous objects.</p>

<h3 style='tab-stops:.5in'><a name=nestedObjects></a>Nested Objects</h3>

<p class=MsoNormal style='tab-stops:.5in'>In addition to defining regular
properties and methods, you can define a property as a &quot;nested&quot;
object.<span style="mso-spacerun: yes">  </span>This syntax allows you to
define one object within another, and at the same time initialize a property of
the outer object to refer to the inner object.<span style="mso-spacerun: yes"> 
</span>For example:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>bottomOfStairs: Room</pre><pre><span style="mso-spacerun: yes">     </span>name = &quot;Bottom of Stairs&quot;</pre><pre><span style="mso-spacerun: yes">     </span>desc = &quot;This dark, narrow chamber is just large enough</pre><pre><span style="mso-spacerun: yes">             </span>to enclose the rusted iron staircase that spirals upwards,</pre><pre><span style="mso-spacerun: yes">             </span>its top lost in the dusty murk above.&quot;</pre><pre><span style="mso-spacerun: yes">     </span>up: MsgConnector</pre><pre><span style="mso-spacerun: yes">     </span>{</pre><pre><span style="mso-spacerun: yes">       </span>desc = &quot;You force yourself to climb the hundreds of stairs...&quot;</pre><pre><span style="mso-spacerun: yes">       </span>destination = topOfStairs</pre><pre><span style="mso-spacerun: yes">     </span>}</pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This example defines, in addition to
the object bottomOfStairs, a separate object of class MsgConnector whose
properties desc and destination are initialized as shown.<span
style="mso-spacerun: yes">  </span>The MsgConnector instance has no name, but
evaluating bottomOfStairs.up will yield a reference to the object.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Whatever it looks like,
bottomOfStairs.up is a perfectly normal property  it's <i>not </i>the name of
an object, but is simply a property that contains a reference to an object.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The example above is almost the same
as this:</p>

<pre><span style='font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre><pre><span style="mso-spacerun: yes">   </span>bottomOfStairs: Room</pre><pre><span style="mso-spacerun: yes">     </span>name = &quot;Bottom of Stairs&quot;</pre><pre><span style="mso-spacerun: yes">     </span>desc = &quot;This dark, narrow chamber is just large enough</pre><pre><span style="mso-spacerun: yes">             </span>to enclose the rusted iron staircase that spirals upwards,</pre><pre><span style="mso-spacerun: yes">             </span>its top lost in the dusty murk above.&quot;</pre><pre><span style="mso-spacerun: yes">     </span>up = connector123</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">   </span>connector123: MsgConnector</pre><pre><span style="mso-spacerun: yes">     </span>desc = &quot;You force yourself to climb the hundreds of stairs...&quot;</pre><pre><span style="mso-spacerun: yes">     </span>destination = topOfStairs</pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The only difference between the first
example and the second is that the MsgConnector object in the second example
has a name (&quot;connector123&quot;), whereas the MsgConnector the first
example is anonymous.<span style="mso-spacerun: yes">  </span>Otherwise, the
two examples are equivalent.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The nested object syntax is purely a
convenience feature.<span style="mso-spacerun: yes">  </span>You can always
write an equivalent set of object definitions without using any nesting, simply
by defining each nested object as a separate, named object.<span
style="mso-spacerun: yes">  </span>Nesting is sometimes a more compact
notation, though, and is especially useful when defining small &quot;helper&quot;
objects.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note that the nested object's
property list <i>must </i>be enclosed in braces.<span style="mso-spacerun:
yes">  </span>You can use template properties in a nested object; these may
appear immediately before or immediately after the object's opening brace, just
as in a regular object definition.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Finding the Enclosing Object</h1>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The compiler automatically defines
the property <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>lexicalParent</span></tt> in each nested object as a
reference to the lexically enclosing object.<span style="mso-spacerun: yes"> 
</span>For example, consider the following object definition:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>outer: object</pre><pre><span style="mso-spacerun: yes">     </span>desc = &quot;This is 'outer'&quot;</pre><pre><span style="mso-spacerun: yes">     </span>inner: object</pre><pre><span style="mso-spacerun: yes">     </span>{</pre><pre><span style="mso-spacerun: yes">       </span>desc = &quot;This is 'inner'  enclosing: &lt;&lt;lexicalParent.desc&gt;&gt;&quot;</pre><pre><span style="mso-spacerun: yes">     </span>}</pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If we evaluate <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>outer.inner.desc</span></tt>,
well see the following displayed:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>This is 'inner'  enclosing: This is 'outer'</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note that lexicalParent is defined as
a property of each nested object.<span style="mso-spacerun: yes">  </span>This
makes it possible for a class specifically designed for instantiation as nested
objects to determine the lexically enclosing object for each of its instances.</p>

<h3 style='tab-stops:.5in'>Class Definition Syntax</h3>

<p class=MsoNormal style='tab-stops:.5in'>You can define a class instead of an
object by adding the keyword &quot;class&quot; before the object name:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>class <i>objectName </i>: <i>class1, class2, ... </i>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>A class definition is otherwise
syntactically identical to an ordinary object definition.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Classes behave very much like
objects, with a few important differences:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l1 level1 lfo3;tab-stops:list .5in'>Classes
     are not included in iterations using the firstObj() and nextObj()
     functions in the <a href="t3tgen.htm">&quot;tads-gen&quot; intrinsic
     function set</a>.</li>
 <li class=MsoNormal style='mso-list:l1 level1 lfo3;tab-stops:list .5in'>The
     compiler does not include classes when building dictionary entries based
     on vocabulary property definitions.</li>
</ul>

<h3 style='tab-stops:.5in'><a name=plusProp></a>Contained Objects</h3>

<p class=MsoNormal style='tab-stops:.5in'>Most TADS games have some sort of
&quot;containment&quot; model that relates objects to one another in a location
hierarchy.<span style="mso-spacerun: yes">  </span>In these models, each object
has a container, and containers may in turn be inside other containers.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The TADS 3 compiler can keep track of
a simple containment hierarchy that gives each object a single container.<span
style="mso-spacerun: yes">  </span>This is an optional feature, so games that
use more complex containment models than the compiler provides do not have to
use this feature; however, games that use a single-container location model can
take advantage of the compiler's location tracking mechanism to simplify object
definitions.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>To use the compiler's location
tracking, you must first tell the compiler which property you are using to
specify an object's container.<span style="mso-spacerun: yes">  </span>This is
called the &quot;+ property&quot; or &quot;plus property,&quot; because the
object syntax for a contained object uses plus signs.<span style="mso-spacerun:
yes">  </span>To define the plus property, use this statement:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>+ property <i>locationProp </i>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This statement must occur as a
top-level statement, outside of any object or function definitions, and must
precede any objects that make use of the containment syntax.<span
style="mso-spacerun: yes">  </span>If you are using this feature, you should
put this statement at the start of your source files.<span style="mso-spacerun:
yes">  </span>(You must put this statement in each source file if you're using
separate compilation, because the scope of the statement is limited to a single
module.)</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Once you specify the plus property,
you can define objects using the &quot;+&quot; notation: before each object
definition, you can insert one or more plus signs to indicate that the object's
location in the containment tree.<span style="mso-spacerun: yes">  </span>An
object with no &quot;+&quot; signs has no implicit container; an object with
one &quot;+&quot; sign is implicitly contained by the most recent object with
no &quot;+&quot; signs; an object with two &quot;+&quot; signs is implicitly
contained by the most recent object with one &quot;+&quot; sign; and so on.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The inner workings of the
&quot;+&quot; property are simple: whenever you use one or more &quot;+&quot;
signs to define an object, the compiler automatically initializes that object's
&quot;+&quot; property to the implied container.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>For example:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>// define the '+' property</pre><pre><span style="mso-spacerun: yes">   </span>// (we need this only once per source file)</pre><pre><span style="mso-spacerun: yes">   </span>+ property location;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>iceCave: Room</pre><pre><span style="mso-spacerun: yes">     </span>sdesc = &quot;Ice Cave&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">   </span>+ nastyKnife: Item</pre><pre><span style="mso-spacerun: yes">     </span>sdesc = &quot;nasty knife&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">   </span>+ rustyKnife: Item</pre><pre><span style="mso-spacerun: yes">     </span>sdesc = &quot;rusty knife&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>We start by specifying that
&quot;location&quot; is the &quot;+&quot; property.<span style="mso-spacerun:
yes">  </span>We then define the object iceCave with no &quot;+&quot; signs,
which specifies no implicit setting for its location property.<span
style="mso-spacerun: yes">  </span>Next, we define the object nastyKnife using
one &quot;+&quot; sign: this indicates that nastyKnife.location is initialized
to iceCave, because iceCave is the most recent object defined with no
&quot;+&quot; signs.<span style="mso-spacerun: yes">  </span>Finally, we
defined rustyKnife with one &quot;+&quot; sign; again, this object's location
is initialized to iceCave, because it's still the last object with no
&quot;+&quot; signs.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>You can use the &quot;+&quot; syntax
to any depth.<span style="mso-spacerun: yes">  </span>Here's an example with
several levels of containers:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>+ property location;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>office: Room</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;Office&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>+ desk: Surface</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;desk&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>++ fileBox: Container</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;file box&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>+++ greenFile: Container</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;green file folder&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>++++ letter: Readable</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;letter&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>++++ memo: Readable</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;memo&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>+++ redFile: Container</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;red file folder&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>++ pen: Item</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;pen&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>+ chair: Chair</pre><pre><span style="mso-spacerun: yes">       </span>sdesc = &quot;chair&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The desk and chair are located
directly in the office, the file box and pen are on the desk, the green and red
files are in the file box, and the letter and memo are in the green file.<span
style="mso-spacerun: yes">  </span>Each object except office has a location
property set to its container.</p>

<h3 style='tab-stops:.5in'>Anonymous Contained Objects</h3>

<p class=MsoNormal style='tab-stops:.5in'>You can combine the anonymous object
syntax and the contained object syntax for an especially concise way of
defining objects.<span style="mso-spacerun: yes">  </span>We could rewrite the
example above much more compactly:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>office: Room</pre><pre><span style="mso-spacerun: yes">   </span><span style="mso-spacerun: yes">    </span>sdesc = &quot;Office&quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>+ Surface sdesc = &quot;desk&quot; ;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>++ Container sdesc = &quot;file box&quot; ;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>+++ Container sdesc = &quot;green file folder&quot; ;</pre><pre><span style="mso-spacerun: yes">   </span>++++ Readable sdesc = &quot;letter&quot; ;</pre><pre><span style="mso-spacerun: yes">   </span>++++ Readable sdesc = &quot;memo&quot; ;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>+++ Container sdesc = &quot;red file folder&quot; ;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>++ Item sdesc = &quot;pen&quot; ;</pre><pre><span style="mso-spacerun: yes">   </span></pre><pre><span style="mso-spacerun: yes">   </span>+ Chair sdesc = &quot;chair&quot; ;</pre>

<h3 style='tab-stops:.5in'><a name=templates></a>sourceTextOrder</h3>

<p class=MsoNormal>The compiler automatically adds the property sourceTextOrder
to each non-class object, and sets the property to an integer giving the
relative order of the object definition in its source file.<span
style="mso-spacerun: yes">  </span>The sourceTextOrder value is guaranteed to
increase monotonically throughout a source file.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>This property is useful because it lets you reliably
determine the order of objects in a source file.<span style="mso-spacerun:
yes">  </span>There's no other way to do this; for example, you can't count on
object loops, using firstObj() and nextObj(), to iterate over the game's
objects in any particular order.<span style="mso-spacerun: yes">  </span>It's
often useful to be able to construct a run-time data structure (such as a list
or a tree) so that the objects appear in the same order as they did in the
source file, and sourceTextOrder is the way to do this.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The sourceTextOrder value is only useful for determining the
relative order of objects in a single source module.<span style="mso-spacerun:
yes">  </span>The compiler resets the counter at the start of each new source
file, so it's not meaningful to compare this property for objects defined in
different modules.</p>

<h3 style='tab-stops:.5in'>Object Templates</h3>

<p class=MsoNormal style='tab-stops:.5in'>In addition to the generic property
list syntax, the TADS compiler provides an alternative property definition
syntax using <i>object templates.</i><span style="mso-spacerun: yes"> 
</span>(These have nothing to do with what C++ calls templates, which are
parameterized types.)<span style="mso-spacerun: yes">  </span>An object
template lets you define an object's properties positionally, rather than by
naming each property explicitly in the object definition.<span
style="mso-spacerun: yes">  </span>Templates provide a concise syntax for
defining properties that you use frequently.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>To define objects using templates,
you must first define the templates themselves.<span style="mso-spacerun:
yes">  </span>You define a template using the <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>object template</span></tt>
statement:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>object template <i>item1 item2 ... </i>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>You can also define a template that
is specific to instances of a class and its subclasses:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><span style="mso-spacerun: yes">  
</span><i>className </i>template <i>item1 item2 ... </i>;</span></tt></p>

<pre><span style='font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre>

<p class=MsoNormal style='tab-stops:.5in'>Each <i>item </i>in the list is a
placeholder for a property; it specifies the name of the property to assign to
the position, and how you will write the property value.<span
style="mso-spacerun: yes">  </span>Each item in a template can be written in
one of these formats:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l0 level1 lfo6;tab-stops:list .5in'>As a
     single-quoted string</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo6;tab-stops:list .5in'>As a
     double-quoted string</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo6;tab-stops:list .5in'>As a
     list</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo6;tab-stops:list .5in'>As an
     operator character followed by a value, where the operator is one of
     these:<br>
     <tt><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>@
     + - * / % -&gt; &amp; ! ~ ,</span></tt><tt><span style='mso-ascii-font-family:
     "Times New Roman";mso-hansi-font-family:"Times New Roman"'><o:p></o:p></span></tt></li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo6;tab-stops:list .5in'>The <tt><span
     style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>inherited</span></tt>
     keyword</li>
</ul>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Each item is written as an example of
how you will supply the item's value in each object, with the item's property
name taking the place of the actual value.<span style="mso-spacerun: yes"> 
</span>For a single-quoted string, write the property name in single quotes;
for a double-quoted string, write the property name in double quotes; for a
list, write the property name in square brackets; and when you use an operator,
write the operator and then the property name.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>An item can be made optional by
adding a question mark (&quot;?&quot;) immediately after the item.<span
style="mso-spacerun: yes">  </span>When the template definition is matched to
an object definition, the compiler will allow an optional item to be omitted.<span
style="mso-spacerun: yes">  </span>The &quot;?&quot; symbol applies <i>only</i>
to the immediately preceding item; there's no grouping syntax that would allow
a single &quot;?&quot; to apply to multiple items.<span style="mso-spacerun:
yes">  </span>If you want to make multiple items optional, you must put a
question mark after each optional item.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Two or more alternatives can be given
for a single item by separating the alternatives with the vertical bar
(&quot;|&quot;) symbol.<span style="mso-spacerun: yes">  </span>Exactly one of
the alternative template items will be matched to an object definition.<span
style="mso-spacerun: yes">  </span>The &quot;|&quot; symbol applies <i>only</i>
to the directly adjacent items; there's no syntax for grouping alternatives
involving multiple items.<span style="mso-spacerun: yes">  </span>A group of
alternatives can be optional, but only as a group: if any item in an
alternative group is marked as optional, then the entire group is optional.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If one of the items in the template
list is the keyword <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>inherited</span></tt>, it indicates that the template
&quot;inherits&quot; the templates of its superclasses, and that the superclass
items are to appear at the same point in the template as the <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>inherited</span></tt>
keyword.<span style="mso-spacerun: yes">  </span>The effect is exactly the same
as if you had defined a set of templates with each superclass template
substituted for the <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>inherited</span></tt> keyword in the new template, plus one
extra definition with nothing substituted for <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>inherited</span></tt>.<span
style="mso-spacerun: yes">  </span>To illustrate, suppose that you make the
following definitions:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>class A: object;</pre><pre><span style="mso-spacerun: yes">   </span>class B: A;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">   </span>A template 'name';</pre><pre><span style="mso-spacerun: yes">   </span>A template 'name' &quot;desc&quot;;</pre><pre><span style="mso-spacerun: yes">   </span>B template 'author' inherited;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The last template, for class B, is <i>identical
</i>to defining each possible inherited template explicitly.<span
style="mso-spacerun: yes">  </span>In other words, you could replace the last
line above with the following:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>B template 'author';</pre><pre><span style="mso-spacerun: yes">   </span>B template 'author' 'name';</pre><pre><span style="mso-spacerun: yes">   </span>B template 'author' 'name' &quot;desc&quot;;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>inherited</span></tt>
keyword can appear at any point in the item list; superclass template items are
substituted at the point at which <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>inherited</span></tt> appears.<span
style="mso-spacerun: yes">  </span>This provides flexibility so that you can
inherit the items from the superclass templates at the beginning, end, or in
the middle of the new template's item list.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Template Examples</h1>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'>As an example of using templates, here's
a template definition that specifies three properties: the first is the
location, which is marked with an &quot;at&quot; sign; the second is the short
description in double quotes; and the third is the long description in double
quotes.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>object template @location &quot;sdesc&quot; &quot;ldesc&quot;;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Once you define a template, you can
use it in object definitions.<span style="mso-spacerun: yes">  </span>To use a
template, simply put the data definitions for the template's items <i>before </i>the
object definition's normal property list, immediately after the object's class
list.<span style="mso-spacerun: yes">  </span>For example, to use the template
above, we could write this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>poemBook: Book @schoolDesk &quot;poem book&quot; </pre><pre><span style="mso-spacerun: yes">     </span>&quot;It's a book of poems. &quot;</pre><pre><span style="mso-spacerun: yes">     </span>readPoem(num)</pre><pre><span style="mso-spacerun: yes">     </span>{</pre><pre><span style="mso-spacerun: yes">       </span>if (num == 1) ; // etc</pre><pre><span style="mso-spacerun: yes">     </span>}</pre><pre><span style="mso-spacerun: yes">     </span>poem1 = &quot;The first poem is by someone named Wadswurth. &quot;</pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><br>
Note that you don't have to put any properties after the template data for the
object, but if you do, you define them using exactly the same syntax that you
use for a non-template object.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Here's an example of a template with
an optional item:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>Thing template 'name' &quot;desc&quot;? ;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">   </span>cardTable: Thing 'card table';</pre><pre><span style="mso-spacerun: yes">   </span>lamp: Thing 'lamp' &quot;It's a fairly ordinary desk lamp. &quot;;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The single template matches both
object definitions, because the &quot;desc&quot; item can be omitted or
included as desired.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>An example using alternation:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>Message template 'name' &quot;messageText&quot; | [messageList];</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">   </span>Message 'one' &quot;This is message one.&quot;;</pre><pre><span style="mso-spacerun: yes">   </span>Message 'two' ['Message 2a.', 'Message 2b.', 'Message 2c.'];</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>In this example, the second item in the
template can either be a double-quoted string, or it can be a list.<span
style="mso-spacerun: yes">  </span>(The contents of the list don't matter to
the template.)</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>How the Compiler Selects Templates</h1>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Templates don't have names.<span
style="mso-spacerun: yes">  </span>The compiler figures out which template you
want to use purely based on the superclass and on types of the values in the
object definition.<span style="mso-spacerun: yes">  </span>For the Book example
above, the compiler sees that you want to use template data consisting of a
value with the &quot;@&quot; symbol followed by two double-quoted strings; the
compiler scans its list of templates and comes up with the template we defined
earlier.<span style="mso-spacerun: yes">  </span>This means that you must take
care not to define two identical templates, because the compiler will not be
able to tell them apart.<span style="mso-spacerun: yes">  </span>If you do
define identical templates, then the compiler will &quot;break the tie&quot; by
using the one defined earliest in the source file.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note that using optional and
alternative items can sometimes create duplicate templates that aren't
obviously duplicates.<span style="mso-spacerun: yes">  </span>For example,
consider these templates:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>Thing template 'vocab' 'name'?;</pre><pre><span style="mso-spacerun: yes">   </span>Thing template 'vocab' 'name' 'desc'?;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">   </span>Thing 'book' 'It\'s a dusty old tome. ';</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>In this case, it's pretty clear to a
human reader that the object definition meant to use the second template - but
the compiler will pick the first, because it matches just as well and it occurs
earlier in the source file.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Another situation where templates can
be ambiguous in form is multiple inheritance.<span style="mso-spacerun: yes"> 
</span>For example:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>A template 'name';</pre><pre><span style="mso-spacerun: yes">   </span>B template 'desc';</pre><pre><span style="mso-spacerun: yes">   </span>myObj: B, A 'this is myObj!';</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>In this case, the object inherits a
matching template from each of its superclasses.<span style="mso-spacerun:
yes">  </span>In this case, though, the compiler has a better way of choosing
among the templates than just using the source file order: it uses the
superclass inheritance order.<span style="mso-spacerun: yes">  </span>So, even
though A's template is defined before B's, the fact that myObj inherits from B
first, then from A, means that B's template is chosen over A's.<span
style="mso-spacerun: yes">  </span>So in this case, myObj.desc is the property
that's set to the string 'this is myObj!'.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1><a name=templateInh></a>Template Inheritance</h1>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>You can use template inheritance to
include superclass templates as continuations of templates for more specialized
classes.<span style="mso-spacerun: yes">  </span>For example, suppose we wanted
to define a couple of basic templates for our Thing class, like so:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>Thing template 'name';</pre><pre><span style="mso-spacerun: yes">   </span>Thing template 'name' &quot;desc&quot;;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>These two templates allow us to
define any Thing instance with a name, and optionally with a description.<span
style="mso-spacerun: yes">  </span>Now, suppose we define Book as a subclass of
Thing, and we want to allow Book instances to define an additional property
giving the author of the book.<span style="mso-spacerun: yes">  </span>Since
Book is a Thing, we still want each Book to be able to define the basic Thing
properties.<span style="mso-spacerun: yes">  </span>The obvious way to do this
would be to create a template for Book with only the author property, plus
another with the author and name, and another with the author, name, and
description:<span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>Book template 'author';</pre><pre><span style="mso-spacerun: yes">   </span>Book template 'author' 'name';</pre><pre><span style="mso-spacerun: yes">   </span>Book template 'author' 'name' &quot;desc&quot;;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If we had more than two Thing
templates, though, this would become tedious.<span style="mso-spacerun: yes"> 
</span>It would also create a maintenance problem: if we ever wanted to add
more Thing templates or change the existing Thing templates, we'd have to
remember to make the corresponding changes to the Book templates as well.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Fortunately, the compiler offers a
better way to define the extended Book templates: template inheritance.<span
style="mso-spacerun: yes">  </span>If you want a template for a subclass -
Book, in this case - to include the templates of its superclasses in addition
to its own templates, you can simply add the <span style='font-family:"Courier New"'>inherited</span>
keyword at the point in the template where you want the inherited templates to
go.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>For our Book template, we'd use
template inheritance like so:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>Book template 'author' inherited;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This single statement is exactly
equivalent to the three we gave earlier, but it's obviously a lot less work to
type this definition, and the definition automatically adjusts to any changes
you make to the Thing templates.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Templates and Object Definition Syntax Variations</h1>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If you use braces around your
property list, you can put the template properties either immediately before or
immediately after the open brace:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>// template properties can go outside the braces...</pre><pre><span style="mso-spacerun: yes">   </span>book1: Book @shelf &quot;red book&quot;</pre><pre><span style="mso-spacerun: yes">   </span>{</pre><pre><span style="mso-spacerun: yes">     </span>ldesc = &quot;It's a red book.&quot;<br
style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></pre><pre><span style="mso-spacerun: yes">   </span>}</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">   </span>// ...or immediately after an open brace</pre><pre><span style="mso-spacerun: yes">   </span>book2: Book</pre><pre><span style="mso-spacerun: yes">   </span>{</pre><pre><span style="mso-spacerun: yes">     </span>@shelf &quot;blue book&quot;</pre><pre><span style="mso-spacerun: yes">     </span>ldesc = &quot;It's a blue book.&quot;<br
style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></pre><pre><span style="mso-spacerun: yes">   </span>}</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>You can use templates with anonymous
objects, as well as with objects that use the &quot;+&quot; containment
specification syntax:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>+ Container &quot;back-pack&quot; &quot;It's a green back-pack. &quot; ;</pre><pre><span style="mso-spacerun: yes">   </span>++ Item &quot;puzzle cube&quot; &quot;You haven't seen one of these in year. &quot;;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Scope and Placement of Template Definitions</h1>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The scope of a template is limited to
a single source file.<span style="mso-spacerun: yes">  </span>If you are
separating your program into several source files, each file must separately
define the templates it uses.<span style="mso-spacerun: yes">  </span>The
easiest way to define templates in several files is to put the &quot;object template&quot;
statements into a header file, and then include the header in each file; this
way, you only have to write the templates once, and if you modify them later,
you only need to make changes in one place.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Object template statements must
appear as top-level statements, outside of any function or object
definitions.<span style="mso-spacerun: yes">  </span>A template can only be
used after it has been defined, so you should normally define your templates
near the start of each source file.<span style="mso-spacerun: yes"> 
</span>Typically, games and libraries should define the templates they use in a
header file so that all source modules can include the same template
definitions.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Templates and Dictionary Properties</h1>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>You <i>cannot </i>use a <a
href="t3dict.htm">dictionary property</a> in an object template.<span
style="mso-spacerun: yes">  </span>Dictionary properties are excluded because
of the special syntax they use (a dictionary property can have its value set to
a list of single-quoted strings, without any grouping brackets for the
list).<span style="mso-spacerun: yes">  </span>If you could use a dictionary
property in a template, it would be possible to create ambiguous templates,
because the compiler might not be able to tell if a single-quoted string were
meant to be another entry in the same property list or a separate property in
the template.</p>

<h3><a name=transient></a>Persistent and Transient Objects</h3>

<p class=MsoNormal>The T3 VM has a built-in subsystem that can save a snapshot
of the state of all of the objects in the system, and later restore the same
set of objects.<span style="mso-spacerun: yes">  </span>This type of saving and
restoring is referred to as persistence, because it lets a set of objects
outlive a particular VM session; one could save a set of objects to a file on
the computers hard disk, exit the program, turn off the computer, and return
later  even weeks or months later  and restore the state of the objects just
as they were when they were saved.</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal>The VM provides two other mechanisms related to saving and
restoring.<span style="mso-spacerun: yes">  </span>First, the VM is capable of
restarting the program, which resets all of the objects in the program to
their initial state, as they were when the program was initially loaded.<span
style="mso-spacerun: yes">  </span>Second, the VM can save multiple in-memory
snapshots of the program, called savepoints, and then roll back changes since
a snapshot; this is called the undo mechanism, because it allows changes made
since a given point in time to be reversed.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Taken together, these four features  save, restore, undo,
restart  are called the persistence mechanisms of the T3 VM.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The persistence mechanisms are all completely
automatic.<span style="mso-spacerun: yes">  </span>To save the current state,
for example, the program simply calls a function (<a href="t3tgen.htm#saveGame">saveGame</a>,
in the <a href="t3tgen.htm">tads-gen</a> function set), providing the name of a
file; the VM automatically creates a file with the given name and writes the
state of all of the objects in the system to the file.<span
style="mso-spacerun: yes">  </span>To restore the same state later, the program
calls another function (<a href="t3tgen.htm#restoreGame">restoreGame</a>),
providing the name of the file previously saved.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>In some cases, it is desirable to prevent an object from
being saved, restored, undone, or reset.<span style="mso-spacerun: yes"> 
</span>For example, if an object is used to keep track of some part of the user
interface, you probably wouldnt want to save and restore the object, because
you wouldnt want the user interfaces state to be affected by a Restore
operation.<span style="mso-spacerun: yes">  </span>When an object isnt part of
the persistent state of the program, the object is called transient.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>(This terminology can be a bit confusing, depending on ones
perspective.<span style="mso-spacerun: yes">  </span>If one is thinking in
terms of the running program, then transient objects can seem more permanent
than the persistent ones, because they outlive operations like Restore and
Restart, while the <i>current</i> state of a persistent object is lost in these
operations, because these functions restore a persistent object to its old
state.<span style="mso-spacerun: yes">  </span>However, if you think about
persistence in terms of saving data to a hard disk, then the terminology fits:
persistent objects can be saved and restored, but transient objects are
fleeting, lasting only as long as the VM is running.)</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>By default, every object is persistent.<span
style="mso-spacerun: yes">  </span>This means that the VM automatically saves,
restores, resets, and undoes every object, unless you specify otherwise.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>To make an object transient, you use the transient keyword
in TADS.<span style="mso-spacerun: yes">  </span>This keyword can be used in
two different ways.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>First, when youre defining an object directly in your
source code, you can preface the object definition with the transient
keyword.<span style="mso-spacerun: yes">  </span>The object definition is
otherwise exactly like any other.<span style="mso-spacerun: yes">  </span>For
example:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">   </span>transient mainOutputStream: OutputStream</pre><pre><span style="mso-spacerun: yes">     </span>// etc</pre><pre><span style="mso-spacerun: yes">   </span>;</pre>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Second, when youre creating an object dynamically, you can
place the transient keyword immediately after the new operator:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>local x = new transient Vector(10);</pre>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>In addition, the <a href="t3tobj.htm">TadsObject</a>
intrinsic class provides the createTransientInstance() method to create a
transient instance of a class.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

</div>

</body>

</html>

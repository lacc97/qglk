<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./t3gram_files/filelist.xml">
<title>Grammar Rules</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Merkin Muffley</o:Author>
  <o:LastAuthor>Dell User</o:LastAuthor>
  <o:Revision>36</o:Revision>
  <o:TotalTime>204</o:TotalTime>
  <o:Created>2000-02-26T00:48:00Z</o:Created>
  <o:LastSaved>2003-01-02T04:54:00Z</o:LastSaved>
  <o:Pages>7</o:Pages>
  <o:Words>3764</o:Words>
  <o:Characters>21456</o:Characters>
  <o:Lines>178</o:Lines>
  <o:Paragraphs>42</o:Paragraphs>
  <o:CharactersWithSpaces>26349</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>125</w:Zoom>
  <w:DrawingGridHorizontalSpacing>6 pt</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>6 pt</w:DrawingGridVerticalSpacing>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:AutoSpaceLikeWord95/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:13.0pt;
	font-family:Arial;}
h6
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:6;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	punctuation-wrap:simple;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
tt
	{mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:1092435998;
	mso-list-type:hybrid;
	mso-list-template-ids:-377693864 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l1
	{mso-list-id:1843546689;
	mso-list-type:hybrid;
	mso-list-template-ids:-752341916 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<h3 style='tab-stops:.5in'>Grammar Rules</h3>

<p class=MsoNormal style='tab-stops:.5in'>The following discussion is rather
abstract and will probably be quite tedious to most readers.<span
style="mso-spacerun: yes">  </span>If you find your eyes glazing over, you
should skip down to the examples in the next section, because the concrete examples
make this all a lot clearer than the theoretical discussion we're about to
embark upon.<span style="mso-spacerun: yes">  </span>Once you've figured out
how the examples work, come back here for the details.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>TADS 3 provides an intrinsic class
called GrammarProd, for &quot;grammar production,&quot; to make it easier to
create a parser.<span style="mso-spacerun: yes">  </span>You do not create
GrammarProd objects directly; instead, the compiler creates these for you when
you define &quot;grammar rules.&quot;</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The term &quot;production&quot; is
used here in a specialized technical sense specific to computerized parsing.<span
style="mso-spacerun: yes">  </span>A production is an element of a grammar that
is composed of smaller parts.<span style="mso-spacerun: yes">  </span>For
example, if we were creating a computerized grammar for English, we might
include a &quot;sentence&quot; production that consists of a subject, a
predicate, and one or more objects, which in turn would themselves be
productions consisting of small word groups.<span style="mso-spacerun: yes"> 
</span>Productions are so named because computer parsers are frequently
designed to build grammatical structures by starting at individual words and
working up through sequentially larger structures; each time a set of words is
recognized as a functional group, the parser <i>produces </i>the larger
structure from the constituent parts, thus the larger structure is called a <i>production</i>.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>One of the most important things about
productions is that a production almost always has more than one way of being
built.<span style="mso-spacerun: yes">  </span>This is really the entire point
of defining productions, because it allows us to recognize the different forms
a particular syntactic element can take.<span style="mso-spacerun: yes"> 
</span>For example, in English, there are many different kinds of noun phrases:
a simple noun, an adjective followed by a noun, a pronoun, a possessive pronoun
followed by a noun, a possessive pronoun followed by an adjective followed by a
noun, a possessive prounoun followed by an adjective followed by another
adjective followed by a noun; we could go on all day.<span style="mso-spacerun:
yes">  </span>Despite all of these different syntactic forms a noun phrase can
take, though, we can label <i>any </i>of these different forms as a noun phrase
and then use it to build up larger sentence structures.<span
style="mso-spacerun: yes">  </span>This means that, when we define our larger
structures, we don't have to worry about all the different ways a noun phrase
can be formed—we simply know that we need a noun phrase, however formed.<span
style="mso-spacerun: yes">  </span>The &quot;noun phrase&quot; production thus
allows us to hide all of this complexity behind a simple label.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>A grammar rule is defined using the <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>grammar</span></tt>
keyword.<span style="mso-spacerun: yes">  </span>A <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>grammar</span></tt>
statement has this form:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>grammar <i>production_name optional_tag </i>: <i>alternative_list </i>: <i>class_list<o:p></o:p></i></pre><pre><i><span style="mso-spacerun: yes">    </span>property_list<o:p></o:p></i></pre><pre><span style="mso-spacerun: yes">  </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>optional_tag</i> is a symbol
or number token enclosed in parentheses.<span style="mso-spacerun: yes"> 
</span>This is not required, but if it is present, it provides a way to
distinguish the rule from other rules associated with the same <i>production_name</i>
at run-time, and to refer to the rule in <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>modify</span></tt> and <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>replace</span></tt>
statements.<span style="mso-spacerun: yes">  </span>This tag is included in the
string in the first element returned by the <a href="#grammarInfo">grammarInfo
method</a>.<span style="mso-spacerun: yes">  </span>If the tag is present, the
combination of the production name, tag, and parentheses forms the full name of
the object, and so this combination must be globally unique, just as any other
object name must be.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>class_list </i>and <i>property_list
</i>are defined in exactly the same way as for ordinary objects.<span
style="mso-spacerun: yes">  </span>The reason there's a class and property list
is that the <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>grammar</span></tt> statement defines an ordinary class, in
addition to defining a GrammarProd object.<span style="mso-spacerun: yes"> 
</span>The ordinary class that is defined has no name, but is otherwise like
any other class.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>production_name </i>specifies
the name of the GrammarProd object.<span style="mso-spacerun: yes">  </span>A given
production name can occur in any number of <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>grammar</span></tt> statements; a <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>grammar</span></tt>
statement does not uniquely define a production object, but simply adds one or
more alternative syntax rules to the production.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>alternative_list </i>is a set
of one or more syntax rules to be associated with the production.<span
style="mso-spacerun: yes">  </span>Each alternative list looks like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span><i>item_list </i>| <i>item_list ...<o:p></o:p></i></pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The vertical bar (the same symbol
used for the bitwise-OR operator) separates multiple item lists, if more than
one is specified (it's also perfectly fine to specify only one item list, in
which case no bar is needed).<span style="mso-spacerun: yes">  </span>Using the
vertical bar to include multiple item lists is equivalent to using a separate <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>grammar</span></tt>
statement for each item list, so it is never necessary to use multiple lists; however,
it is often convenient to specify a group of similar item lists together.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Each item list specifies a syntax
rule for the production.<span style="mso-spacerun: yes">  </span>An item list
looks like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span><i>optional_qualifiers<span style="mso-spacerun: yes">  </span>item1 item2 ... itemN<span style="mso-spacerun: yes">  </span>optional_star<o:p></o:p></i></pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Each <i>item </i>in the list can be
one of the following:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l1 level1 lfo3;tab-stops:list .5in'>A
     token type (an <tt><span style='font-family:"Courier New";mso-bidi-font-family:
     "Times New Roman"'>enum token</span></tt> value).<span
     style="mso-spacerun: yes">  </span>A token type item tells the parser to
     match any input token of the given type.</li>
 <li class=MsoNormal style='mso-list:l1 level1 lfo3;tab-stops:list .5in'>A
     literal string, enclosed in single quotes.<span style="mso-spacerun:
     yes">  </span>This matches the actual text of an input token.<span
     style="mso-spacerun: yes">  </span>If a default dictionary is in effect at
     compile-time when the rule is defined (via a <tt><span style='font-family:
     "Courier New";mso-bidi-font-family:"Times New Roman"'><a
     href="t3dict.htm#dictionaryStatement">dictionary</a></span></tt>
     statement), the compiler automatically enters the text into the
     dictionary, associating it with the production object and the <tt><span
     style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>miscVocab</span></tt>
     property.<span style="mso-spacerun: yes">  </span>Literals are matched
     using the same comparison rule as the <a href="t3dict.htm">Dictionary</a>
     object used at the time of parsing; this means that any case folding,
     truncation, accent elisions, and other special matching rules that the
     Dictionary uses are applied in the same manner to grammar literals.</li>
 <li class=MsoNormal style='mso-list:l1 level1 lfo3;tab-stops:list .5in'>A
     dictionary property.<span style="mso-spacerun: yes">  </span>This matches
     an input token that appears in the dictionary with the given property.</li>
 <li class=MsoNormal style='mso-list:l1 level1 lfo3;tab-stops:list .5in'>A list
     of dictionary properties enclosed in angle brackets (“&lt; &gt;”).<span
     style="mso-spacerun: yes">  </span>This matches an input token that
     appears in the dictionary with <i>any</i> of the listed properties.</li>
 <li class=MsoNormal style='mso-list:l1 level1 lfo3;tab-stops:list .5in'>A
     production object (a <i>production_name </i>symbol from another <tt><span
     style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>grammar</span></tt>
     statement, or even the name of the current statement's production
     object).<span style="mso-spacerun: yes">  </span>This matches if any of
     the alternatives defined for the sub-production match.</li>
 <li class=MsoNormal style='mso-list:l1 level1 lfo3;tab-stops:list .5in'>A
     group of alternative sub-lists enclosed in parentheses, with the
     alternative sub-lists separated by vertical bars.</li>
</ul>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Each <i>item</i> type can optionally
be followed by an arrow symbol, &quot;-&gt;&quot; (a hyphen followed by a
greater-than sign), then a property name.<span style="mso-spacerun: yes"> 
</span>If this sequence is present, it indicates that, when the parser
successfully matches the item, it will store the matching value in the given
property of the object created to represent the production match.<span
style="mso-spacerun: yes">  </span>For a token type or dictionary property
item, the value stored in the property is simply the token value of the input
token that matches the item.<span style="mso-spacerun: yes">  </span>For a
sub-production item, the value stored in the property is the object created to
represent the sub-production match.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>optional_star</i>, if present,
is simply an asterisk, &quot;*&quot;.<span style="mso-spacerun: yes"> 
</span>This symbol indicates that any input tokens that remain in the input
after the tokens that match the syntax rule up to this point should simply be
ignored.<span style="mso-spacerun: yes">  </span>In a sense, the &quot;*&quot;
is a &quot;wildcard&quot; symbol that matches everything remaining in the input
token list; however, you shouldn't think of it this way, because that's not
really how it works.<span style="mso-spacerun: yes">  </span>The &quot;*&quot; doesn't
actually match anything; instead, it simply indicates that any remaining tokens
should be ignored.<span style="mso-spacerun: yes">  </span>If an alternative of
the root production does <i>not </i>end with a &quot;*&quot; symbol, either
directly in the rule of the alternative in the root production or indirectly in
the last subproduction, the parser will match the alternative only if the root
alternative matches the <i>entire </i>input token list.<span
style="mso-spacerun: yes">  </span>If the root alternative does end (directly
or indirectly) with the &quot;*&quot; symbol, however, the parser will match
the alternative even if extra input tokens remain after matching the alternative's
items.<span style="mso-spacerun: yes">  </span>The &quot;*&quot; symbol, if
present, must always be the last item in an alternative's list.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The <i>optional_qualifiers</i>, if
present, specify additional information about the alternative.<span
style="mso-spacerun: yes">  </span>Only one qualifier is currently valid:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><span style="mso-spacerun: yes"> 
</span>[badness <i>number</i>]<o:p></o:p></span></tt></p>

<pre><span style='font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre>

<p class=MsoNormal style='tab-stops:.5in'>This qualifier assigns the
alternative a &quot;badness&quot; rating, which can be used to create catch-all
syntax patterns that you don't want to use except as a last resort; assigning a
badness rating tells the parser that the alternative should be ignored until all
other alternatives are exhausted.<span style="mso-spacerun: yes">  </span>This
is especially useful for handling syntax errors in the user input, because it
allows you to create alternatives that match anything in particular parts of
the input, which helps pinpoint where the problem is, which in turn lets you
give the user better feedback about the problem.</p>

<h3 style='tab-stops:.5in'>Modifying and Replacing Grammar Rules</h3>

<p class=MsoNormal style='tab-stops:.5in'>A grammar rule object can be replaced
or modified by another grammar rule, just as a normal object can be replaced or
modified, using the <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>replace</span></tt> and <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>modify</span></tt> keywords.<span
style="mso-spacerun: yes">  </span>You might want to modify or replace a
grammar rule when you are using a library that defines a set of grammar rules,
because this allows you to use the rules the library defines, but remove or
change specific rules whose library definitions are not what you want.</p>

<p class=MsoNormal style='tab-stops:.5in'><b><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></b></p>

<p class=MsoNormal style='tab-stops:.5in'>To use <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>modify</span></tt> with a
grammar rule, use this syntax:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>modify grammar <i>production_name tag </i>: <i>alternative_list</i> :</pre><pre><i><span style="mso-spacerun: yes">    </span>property_list</i></pre><pre><span style="mso-spacerun: yes">  </span>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This is <i>almost</i> the same as the
normal <tt><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>grammar</span></tt>
syntax, but note that no class list follows the colon after the alternative
list.<span style="mso-spacerun: yes">  </span>No superclasses are specified
with <tt><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>modify</span></tt>
because the modified object has the same superclass or superclasses as the
original object being modified.<span style="mso-spacerun: yes">  </span>Note
also that the <i>tag</i> (a token enclosed in parentheses) is required, because
this provides the unique name for the match object that distinguishes it from
other match objects defined for the same production name.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note that the <i>alternative_list</i>
is optional: if you leave it out (so you just put two colons in a row after the
name), then the compiler retains the original alternative list of the rule
being modified.<span style="mso-spacerun: yes">  </span>This lets you override
just the properties or methods of the grammar rule object, without changing any
of the grammar it matches.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>To use <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>replace</span></tt> with
a grammar rule, use this syntax:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><span style="mso-spacerun: yes"> 
</span>replace grammar <i>production_name tag</i> : <i>alternative_list </i>: <i>class_list</i><o:p></o:p></span></tt></p>

<p class=MsoNormal style='tab-stops:.5in'><tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><span style="mso-spacerun: yes">   
</span><i>property_list</i><o:p></o:p></span></tt></p>

<p class=MsoNormal style='tab-stops:.5in'><tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><span style="mso-spacerun: yes"> 
</span>;<o:p></o:p></span></tt></p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This is exactly the same as a normal <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>grammar</span></tt>
definition, except that the <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>replace</span></tt> keyword precedes
the definition.<i><o:p></o:p></i></p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If you use <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>replace</span></tt>
or <tt><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>modify</span></tt>
with a grammar rule, the original grammar rule is completely replaced by the
new grammar rule.<span style="mso-spacerun: yes">  </span>In this respect, <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>replace</span></tt>
or <tt><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>modify</span></tt>
behave exactly the same way.<span style="mso-spacerun: yes">  </span>The
differences between the two are their treatment of the original object's
property list (in the case of <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>replace</span></tt>, the original list
is completely lost; in the case of <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>modify</span></tt>, the original
properties are inherited by the modified object) and of the original's
superclass (<tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>replace</span></tt> specifies a brand new superclass, and <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>modify</span></tt>
uses the original object's superclass).</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>If you want to delete an existing
grammar rule entirely, you can use the <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>replace</span></tt> syntax, and specify
an unmatchable alternative list.<span style="mso-spacerun: yes">  </span>An
alternative list is unmatchable if it contains a token string that the
tokenizer will never produce; for example, in most cases, tokenizers do not
return spaces as tokens, so you can use the string <tt><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>' '</span></tt> as an
unmatchable alternative:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>replace grammar nounPhrase(1): ' ': object;</pre>

<h3 style='tab-stops:.5in'>Calling the Parser</h3>

<p class=MsoNormal style='tab-stops:.5in'>To use a grammar rule, simply call
the <tt><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>parseTokens()</span></tt>
method in a production object.<span style="mso-spacerun: yes">  </span>(You
must include the header file &quot;gramprod.h&quot; in your source file to use
this method, because the method comes from the GrammarProd intrinsic class,
which is defined in this header file.)</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The parseTokens() method takes the
following arguments:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l0 level1 lfo6;tab-stops:list .5in'>A
     token list.<span style="mso-spacerun: yes">  </span>Each entry in this
     list is a token specifier, which is a sublist consisting of at least two
     elements: the first element is the value of the token, and the second
     element is the type of the token.<span style="mso-spacerun: yes"> 
     </span>Each token's sublist can include more elements if desired; the
     parser will preserve the additional elements, but doesn't currently use
     any beyond the first two.<span style="mso-spacerun: yes">  </span>This
     format is compatible with the <a href="t3tok.htm">Tokenizer</a> class's
     format, so you can simply feed a token list produced by the Tokenizer class
     directly into the parseTokens() method.</li>
 <li class=MsoNormal style='mso-list:l0 level1 lfo6;tab-stops:list .5in'>A <a
     href="t3dict.htm">Dictionary</a> object, or nil if no dictionary is to be
     used.<span style="mso-spacerun: yes">  </span>If this argument is not nil,
     it must be an object of intrinsic class Dictionary.<span
     style="mso-spacerun: yes">  </span>If any of the syntax rules that the
     parser encounters include dictionary property items, the parser will look
     up the corresponding token in the given dictionary to determine the
     properties under which the word is defined.<span style="mso-spacerun:
     yes">  </span>A dictionary is not required if no dictionary properties are
     used in the syntax rules to be examined.<span style="mso-spacerun: yes"> 
     </span>The Dictionary also specifies how literals in grammar rules are
     matched to tokens: literals are matched using the Dictionary's
     &quot;comparator&quot; object, so that literals are matched using the same
     rules that the Dictionary uses to match tokens against dictionary words.</li>
</ul>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Call this method on the
&quot;root&quot; production of the grammar you wish to parse.<span
style="mso-spacerun: yes">  </span>There's nothing special about a root
production object—you can use any production here.<span style="mso-spacerun:
yes">  </span>For example, if you want to parse just a noun phrase, you can
call <tt><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>parseTokens()</span></tt>
on your noun phrase production object, even if the noun phrase production is
used as a sub-production in other rules.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>This method returns a list of
matches.<span style="mso-spacerun: yes">  </span>If the return list is empty, it
indicates that there were no matches at all.<span style="mso-spacerun: yes"> 
</span>Otherwise, each entry in the list is the top object of a &quot;match
tree.&quot;</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>A match tree is a tree of objects
that the parser dynamically creates to represent the syntax structure of the
match.<span style="mso-spacerun: yes">  </span>Each object is an instance of
one of the unnamed classes defined in a <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>grammar</span></tt> statement.<span
style="mso-spacerun: yes">  </span>Each of these objects has the properties
that appear after arrow symbols (&quot;-&gt;&quot;) in the grammar item list
set to the actual values from the input token list.</p>

<h3 style='tab-stops:.5in'>Finding the Original Tokens</h3>

<p class=MsoNormal style='tab-stops:.5in'>As the parser builds the match tree,
it sets properties of each match object to indicate the indices of the first
and last tokens involved in the match; these bounds are inclusive.<span
style="mso-spacerun: yes">  </span>The properties the parser sets are called
firstTokenIndex and lastTokenIndex.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>In addition, the parser automatically
sets the tokenList property of each match tree object to a reference to the
original token list passed into <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>parseTokens()</span></tt>.<span
style="mso-spacerun: yes">  </span>So, for a given match tree object <i>match</i>,
the tokens matching the production can be obtained as follows:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><span style="mso-spacerun: yes"> 
</span>toks = match.tokenList.sublist(<o:p></o:p></span></tt></p>

<p class=MsoNormal style='tab-stops:.5in'><tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><span style="mso-spacerun: yes">    
</span>match.firstTokenIndex, <o:p></o:p></span></tt></p>

<p class=MsoNormal style='tab-stops:.5in'><tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'><span style="mso-spacerun: yes">    
</span>match.lastTokenIndex - match.firstTokenIndex + 1);<o:p></o:p></span></tt></p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>In addition to the token list, the
parser stores a list of &quot;match results&quot; in each object in the match
tree, in the property tokenMatchList.<span style="mso-spacerun: yes"> 
</span>This list gives the result of the matchValues() method in the
Dictionary's comparator object for each token that matched a literal in a
grammar rule.<span style="mso-spacerun: yes">  </span>Each element of this list
gives the match result for the corresponding element of the token list, so
tokenMatchList[3] gives the matchValues() result for the third token.<span
style="mso-spacerun: yes">  </span>If a token matches a dictionary property
rather than a literal, its tokenMatchList entry will be nil, since
matchValues() is not used to match such tokens.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The tokenMatchList information can be
used to find out how well a particular token matched a grammar literal.<span
style="mso-spacerun: yes">  </span>For example, this can be used to determine
if the token matched with truncation, or with accent substitution using an
equivalence mapping (see the <a href="t3strcmp.htm">StringComparator</a> class
for more details on these types of matches).</p>

<p class=MsoNormal style='tab-stops:.5in'><span style="mso-spacerun:
yes"> </span></p>

<p class=MsoNormal style='tab-stops:.5in'>(Note: to be precise, the parser uses
the properties <a href="t3export.htm">exported</a> under the global names
&quot;GrammarProd.firstTokenIndex&quot; and &quot;GrammarProd.lastTokenIndex&quot;
for the indices, &quot;GrammarProd.tokenList&quot; for the token list, and
&quot;GrammarProd.tokenMatchList&quot; for the token match result list.<span
style="mso-spacerun: yes">  </span>Since the GrammarProd header file, <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>gramprod.h</span></tt>,
defines these exports, most users can ignore this detail.)</p>

<h3 style='tab-stops:.5in'><a name=grammarInfo></a>grammarInfo</h3>

<p class=MsoNormal style='tab-stops:.5in'>The compiler automatically generates
a method called &quot;grammarInfo&quot; for each match object class.<span
style="mso-spacerun: yes">  </span>This method provides information that allows
the program to traverse a match tree without knowing anything about the
structure of the tree, which is useful for debugging as well as for searching a
tree for particular types of matches.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The grammarInfo method returns a
list.<span style="mso-spacerun: yes">  </span>The first element in the list is
the name of the match, which is simply the name of the production, plus the tag
if one was specified.<span style="mso-spacerun: yes">  </span>Each subsequent
element is the value of one of the properties used after an arrow
(&quot;-&gt;&quot;) in the production's rule or rules; the properties appear in
the list in the same order they are specified in the rule.<span
style="mso-spacerun: yes">  </span>If the rule contains multiple alternatives,
each property appears only once in the list.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>For example, suppose we define a rule
like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>grammar nounPhrase(1): adjective-&gt;adj_ noun-&gt;noun_ : object;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Now, suppose this rule matched the
input &quot;magic book.&quot;<span style="mso-spacerun: yes">  </span>The
grammarInfo method for the match object would look like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>['nounPhrase(1)', 'magic', 'book']</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The first element is the production
name with the tag.<span style="mso-spacerun: yes">  </span>The second element
is the value of the adj_ property, which in this case is the literal token matched;
likewise, the third element is the value of the noun_ property, which is
another literal token.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The grammarInfo method can be used to
write generic routines that traverse arbitrary match trees.<span
style="mso-spacerun: yes">  </span>For example, we could write a simple routine
to display, for debugging purposes, the contents of a match tree:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>showGrammar(match, indent)</pre><pre>{</pre><pre><span style="mso-spacerun: yes">  </span>local info;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* indent by the desired amount (two spaces per level) */</pre><pre><span style="mso-spacerun: yes">  </span>for (local i = 0 ; i &lt; indent ; ++i)</pre><pre><span style="mso-spacerun: yes">    </span>&quot;\ \ &quot;;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* if it's not a sub-production, treat it specially */</pre><pre><span style="mso-spacerun: yes">  </span>if (match == nil)</pre><pre><span style="mso-spacerun: yes">  </span>{</pre><pre><span style="mso-spacerun: yes">    </span>/* this tree element isn't used – skip it */</pre><pre><span style="mso-spacerun: yes">    </span>return;<br
style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></pre><pre><span style="mso-spacerun: yes">  </span>}</pre><pre><span style="mso-spacerun: yes">  </span>else if (dataType(match) == TypeSString)</pre><pre><span style="mso-spacerun: yes">  </span>{</pre><pre><span style="mso-spacerun: yes">    </span>/* it's a literal token match – show it */</pre><pre><span style="mso-spacerun: yes">    </span>&quot;'&lt;&lt;match&gt;&gt;'\n&quot;;</pre><pre><span style="mso-spacerun: yes">    </span>return;</pre><pre><span style="mso-spacerun: yes">  </span>}</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* get the grammar info for the object */</pre><pre><span style="mso-spacerun: yes">  </span>info = match.grammarInfo();</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* show the production rule name, and the original text it matched */</pre><pre><span style="mso-spacerun: yes">  </span>&quot;&lt;&lt;info[1]&gt;&gt; [&lt;&lt;showGrammarText(match)&gt;&gt;]\n&quot;;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* show each sub-match */</pre><pre><span style="mso-spacerun: yes">  </span>for (local i = 2 ; i &lt;= info.length ; ++i)</pre><pre><span style="mso-spacerun: yes">   </span><span style="mso-spacerun: yes"> </span>showGrammar(info[i], indent + 1);</pre><pre>}</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre>/* show the text of a match tree item */</pre><pre>showGrammarText(match)</pre><pre>{</pre><pre><span style="mso-spacerun: yes">  </span>for (local i = match.firstTokenIndex ; i &lt;= match.lastTokenIndex ; ++i)</pre><pre><span style="mso-spacerun: yes">  </span>{</pre><pre><span style="mso-spacerun: yes">    </span>/* show a space before each entry except the first */</pre><pre><span style="mso-spacerun: yes">    </span>if (i != match.firstTokenIndex)</pre><pre><span style="mso-spacerun: yes">      </span>&quot; &quot;;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">    </span>/* show this token's text */</pre><pre><span style="mso-spacerun: yes">    </span>&quot;&lt;&lt;match.tokenList[i]&gt;&gt;&quot;;</pre><pre><span style="mso-spacerun: yes">  </span>}<br
style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></pre><pre>}</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h3 style='tab-stops:.5in'>Sample Grammar Rules</h3>

<p class=MsoNormal style='tab-stops:.5in'>Let's define some grammar rules for a
very simple noun phrase parser.<span style="mso-spacerun: yes">  </span>For the
purposes of this example, we'll keep things very simple: our noun phrases will
consist of a noun, or an adjective and a noun, or an adjective and an adjective
and a noun, or so on.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The simplest way we could define
these rules is by enumerating all of the different phrasings we could use.<span
style="mso-spacerun: yes">  </span>So, we could write something like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>grammar nounPhrase: noun-&gt;noun_: object;</pre><pre>grammar nounPhrase: adjective-&gt;adj_ noun-&gt;noun_: object;</pre><pre>grammar nounPhrase: adjective-&gt;adj1_ adjective-&gt;adj2_ noun-&gt;noun_:</pre><pre><span style="mso-spacerun: yes">   </span>object;</pre><pre>grammar nounPhrase: adjective-&gt;adj1_ adjective-&gt;adj2_</pre><pre><span style="mso-spacerun: yes">   </span>adjective-&gt;adj3_ noun-&gt;noun_: object;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre>

<p class=MsoNormal style='tab-stops:.5in'>And so on, up to some fixed limit to
the number of adjectives we'll allow.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Now, this will work, but it's not
very flexible.<span style="mso-spacerun: yes">  </span>If we stop at six
adjectives, users might complain that they can't use eight.<span
style="mso-spacerun: yes">  </span>We could add phrasings for seven and eight
adjectives, but then users might complain about ten.<span style="mso-spacerun:
yes">  </span>Our work would never end.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Fortunately, there is a more general
approach.<span style="mso-spacerun: yes">  </span>The recursion-minded reader
might have by now observed that we could in principle express a rule for an
unlimited number of adjectives by saying that a noun phrase is a noun, or an
adjective followed by a noun phrase.<span style="mso-spacerun: yes"> 
</span>This neatly subsumes any number of adjectives: with one adjective, we
have a noun phrase consisting of an adjective followed by a noun phrase
consisting of a noun; with two adjectives, we have an adjective followed by a
noun phrase which consists of an adjective followed by a noun phrase which
consists of a noun; and so on.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Not only can we express our noun
phrase syntax this way in principle, we can express it this way in fact.<span
style="mso-spacerun: yes">  </span>This is precisely the kind of thing at which
our production scheme excels.<span style="mso-spacerun: yes">  </span>Here's
the simpler and much more flexible noun phrase grammar:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>grammar nounPhrase: noun-&gt;noun_: object;</pre><pre>grammar nounPhrase: adjective-&gt;adj_ nounPhrase-&gt;np_: object;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>That's it—this completely solves our
problem, no matter how many adjectives our verbose user types.<span
style="mso-spacerun: yes">  </span>Suppose the user types &quot;little red
wagon&quot;: we first match the second alternative (with adjective &quot;little&quot;),
leaving &quot;red wagon&quot; still to be parsed; we then match the second
alternative again (with adjective &quot;red&quot;), leaving just
&quot;wagon&quot; remaining; and finally we match the first alternative (with
noun &quot;wagon&quot;).<span style="mso-spacerun: yes">  </span>Here's how we
actually call the parser to parse this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>match = nounPhrase.parseTokens(tokList, gDict);</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>(Where do we get the tokList value to
pass into the method?<span style="mso-spacerun: yes">  </span>We can use the
standard run-time library class <a href="t3tok.htm">Tokenizer</a>, or a
subclass, and call its <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>tokenize()</span></tt> method to produce a token list from a
simple string we want to parse.)</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>So, what good is all of this?<span
style="mso-spacerun: yes">  </span>Yes, we've built a set of rules that define
a syntax structure, and we know how to call the parser to scan the rules.<span
style="mso-spacerun: yes">  </span>However, how do we actually use this for
anything?<span style="mso-spacerun: yes">  </span>What do we know, apart from
whether or not an input token list matches the syntax?<span
style="mso-spacerun: yes">  </span>It turns out we know a great deal.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>When the parser matches our syntax
lists, it creates &quot;match trees&quot; that give us the details of exactly
how the input tokens are structured, according to our grammar.<span
style="mso-spacerun: yes">  </span>The match tree consists of objects that the
parser creates dynamically; these objects are instances of our <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>grammar</span></tt>
objects—not of the production objects, but of the unnamed &quot;processor&quot;
objects that go with the <tt><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>grammar</span></tt> statement.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Let us, for the moment, assign some
arbitrary labels to our processor objects.<span style="mso-spacerun: yes"> 
</span>These aren't really class names – we're just using these to keep track
of what's going on:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>grammar nounPhrase: noun-&gt;noun_: object; // pseudo-class &quot;A&quot;</pre><pre>grammar nounPhrase: adjective-&gt;adj_ nounPhrase-&gt;np_: </pre><pre><span style="mso-spacerun: yes">    </span>object; // pseudo-class &quot;B&quot;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>When we call the <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>parseTokens()</span></tt>
method, the parser builds up match trees consisting of instances of
&quot;A&quot; and &quot;B&quot;.<span style="mso-spacerun: yes">    </span>For
our &quot;little red wagon&quot; example, here's what the match tree looks
like, assigning arbitrary names to the objects (which wouldn't really happen,
since they're dynamically created):</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>obj1: B<span style="mso-spacerun: yes">  </span>adj_ = 'little'<span style="mso-spacerun: yes">  </span>np_ = obj2 ;</pre><pre>obj2: B<span style="mso-spacerun: yes">  </span>adj_ = 'red'<span style="mso-spacerun: yes">     </span>np_ = obj3 ;</pre><pre>obj3: A<span style="mso-spacerun: yes">  </span>noun_ = 'wagon' ;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The &quot;root&quot; of the match
tree is obj1.<span style="mso-spacerun: yes">  </span>This example might make
it more apparent why we call this a &quot;tree&quot;: obj1 is the root, with an
adjective on one branch and obj2 on the other; obj2 in turn branches to an
adjective and obj3; and obj3 has a noun.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The next step in making these match
trees useful is to give them some methods.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>The fact that a nounPhrase can be
used in syntax anywhere a noun phrase is required means that all of the
different alternative forms of noun phrases should provide a common
interface.<span style="mso-spacerun: yes">  </span>Clearly, they don't right
now: each alternative has its own set of properties.<span style="mso-spacerun:
yes">  </span>However, these properties are <i>not </i>meant as a public
interface; they're intended only for the use of the specific alternative
processor object.<span style="mso-spacerun: yes">  </span>What we must now do
is define a public interface, which provides a common set of functionality for
every nounPhrase alternative, and then specify an alternative-specific
implementation of the public interface; the implementation effectively provides
the bridge from the alternative-specific properties to the common information
that any noun phrase must provide.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>What sorts of things should noun
phrases do?<span style="mso-spacerun: yes">  </span>In a real system, the
primary thing we need from a noun phrase production is to resolve itself to a
set of game objects.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>For now, though, let's define a very
simple public interface that simply provides a debugging display of the
object.<span style="mso-spacerun: yes">  </span>To do this, we'll define a
method, debugPrint(), that any nounPhrase processor object must provide.<span
style="mso-spacerun: yes">  </span>Here's how we could implement this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>grammar nounPhrase: noun-&gt;noun_: object</pre><pre><span style="mso-spacerun: yes">  </span>debugPrint() { &quot;noun phrase: noun = &lt;&lt;noun_&gt;&gt;\n&quot;; }</pre><pre>;</pre><pre>grammar nounPhrase: adjective-&gt;adj_ nounPhrase-&gt;np_: object</pre><pre><span style="mso-spacerun: yes">  </span>debugPrint()</pre><pre><span style="mso-spacerun: yes">  </span>{</pre><pre><span style="mso-spacerun: yes">    </span>&quot;noun phrase: adjective = &lt;&lt;adj_&gt;&gt;, nounPhrase = {\n&quot;;</pre><pre><span style="mso-spacerun: yes">    </span>np_.debugPrint();</pre><pre><span style="mso-spacerun: yes">    </span>&quot;}\n&quot;;<br
style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></pre><pre><span style="mso-spacerun: yes">  </span>}</pre><pre>;</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Note how the public interface method
is implemented in every noun phrase processor object, but the actual
implementation varies according to the underlying information in the processor
object.<span style="mso-spacerun: yes">  </span>We actually take advantage of
this in the recursive call to <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>np_.debugPrint()</span></tt> in the
second alternative: we know for a fact that <tt><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>np_</span></tt> refers to a noun phrase
processor object, because our syntax says so, so we can call its <tt><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>debugPrint()</span></tt>
method without having to know what kind of nounPhrase it is.<span
style="mso-spacerun: yes">  </span>This is important in our &quot;little red
wagon&quot; example, because we'll actually have both kinds of nounPhrase
alternatives present.</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>Here's some code that will parse a
noun phrase and then show the debugging display for the result:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre><span style="mso-spacerun: yes">  </span>local str;</pre><pre><span style="mso-spacerun: yes">  </span>local toks;</pre><pre><span style="mso-spacerun: yes">  </span>local match;</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* ask for a string of input */</pre><pre><span style="mso-spacerun: yes">  </span>&quot;&gt;&quot;;</pre><pre><span style="mso-spacerun: yes">  </span>str = inputLine();</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* tokenize the string with the standard tokenizer */</pre><pre><span style="mso-spacerun: yes">  </span>toks = Tokenizer.tokenize(str);</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* parse the tokens */</pre><pre><span style="mso-spacerun: yes">  </span>match = nounPhrase.parseTokens(toks, gDict);</pre><pre><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></pre><pre><span style="mso-spacerun: yes">  </span>/* display the match tree */</pre><pre><span style="mso-spacerun: yes">  </span>for (local i = 1, local cnt = match.length() ; i &lt;= cnt ; ++i)</pre><pre><span style="mso-spacerun: yes">  </span>{</pre><pre><span style="mso-spacerun: yes">    </span>&quot;Match #&lt;&lt;i&gt;&gt;:\n&quot;;</pre><pre><span style="mso-spacerun: yes">    </span>match[i].debugPrint();</pre><pre><span style="mso-spacerun: yes">  </span>}</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'>For our &quot;little red wagon&quot;
example, we'll see something like this:</p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<pre>Match #1:</pre><pre>noun phrase: adjective = little, nounPhrase = {</pre><pre>noun phrase: adjective = red, nounPhrase = {</pre><pre>noun phrase: noun = wagon</pre><pre>}</pre><pre>}</pre>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='tab-stops:.5in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

</div>

</body>

</html>
